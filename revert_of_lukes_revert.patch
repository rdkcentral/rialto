commit 2fa531e861ccfce712493e5470f41ad4acc567e7
Author: Marcin Wojciechowski <marcin.wojciechowski@sky.uk>
Date:   Wed Nov 2 14:32:18 2022 +0100

    Revert "Revert main thread change (#128)"
    
    This reverts commit 3d53c434b757d48595d44599c4f28b6c8daa6b23.

diff --git a/media/server/main/CMakeLists.txt b/media/server/main/CMakeLists.txt
index 2c2c064..3090278 100644
--- a/media/server/main/CMakeLists.txt
+++ b/media/server/main/CMakeLists.txt
@@ -45,6 +45,7 @@ add_library(
         source/MediaKeysServerInternal.cpp
         source/MediaKeysCapabilities.cpp
         source/MediaKeySession.cpp
+        source/MainThread.cpp
         )
 
 target_include_directories(
diff --git a/media/server/main/include/IMainThread.h b/media/server/main/include/IMainThread.h
new file mode 100644
index 0000000..0e7ceb1
--- /dev/null
+++ b/media/server/main/include/IMainThread.h
@@ -0,0 +1,109 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FIREBOLT_RIALTO_SERVER_I_MAIN_THREAD_H_
+#define FIREBOLT_RIALTO_SERVER_I_MAIN_THREAD_H_
+
+#include "IMainThread.h"
+#include <functional>
+#include <memory>
+#include <utility>
+
+namespace firebolt::rialto::server
+{
+class IMainThread;
+
+/**
+ * @brief IMainThread factory class, gets the concrete implementation of IMainThread
+ */
+class IMainThreadFactory
+{
+public:
+    IMainThreadFactory() = default;
+    virtual ~IMainThreadFactory() = default;
+
+    /**
+     * @brief Create a IMainThreadFactory instance.
+     *
+     * @retval the factory instance or null on error.
+     */
+    static std::shared_ptr<IMainThreadFactory> createFactory();
+
+    /**
+     * @brief IMainThread factory method, gets a concrete implementation of IMainThread
+     *
+     * @retval the main thread instance or null on error.
+     */
+    virtual std::shared_ptr<IMainThread> getMainThread() const = 0;
+};
+
+/**
+ * @brief The definition of the IMainThread interface.
+ */
+class IMainThread
+{
+public:
+    using Task = std::function<void()>;
+
+    IMainThread() = default;
+    virtual ~IMainThread() = default;
+
+    IMainThread(const IMainThread &) = delete;
+    IMainThread(IMainThread &&) = delete;
+    IMainThread &operator=(const IMainThread &) = delete;
+    IMainThread &operator=(IMainThread &&) = delete;
+
+    /**
+     * @brief Register a client on the main thread.
+     *
+     * Required by clients who want to enqueue tasks on the main thread.
+     *
+     * @retval The registered client id.
+     */
+    virtual int32_t registerClient() = 0;
+
+    /**
+     * @brief Unregister a client on the main thread.
+     *
+     * Should be called on the main thread.
+     * After been called the client will no longer be able to enqueue tasks.
+     *
+     * @param[in]  clientId : The id of the registered client.
+     */
+    virtual void unregisterClient(uint32_t clientId) = 0;
+
+    /**
+     * @brief Enqueue a task on the main thread and return.
+     *
+     * @param[in]  clientId : The id of the registered client.
+     * @param[in]  task     : Task to queue.
+     */
+    virtual void enqueueTask(uint32_t clientId, Task task) = 0;
+
+    /**
+     * @brief Enqueue a task on the main thread and wait for it to finish before returning.
+     *
+     * @param[in]  clientId : The id of the registered client.
+     * @param[in]  task     : Task to queue.
+     */
+    virtual void enqueueTaskAndWait(uint32_t clientId, Task task) = 0;
+};
+} // namespace firebolt::rialto::server
+
+#endif // FIREBOLT_RIALTO_SERVER_I_MAIN_THREAD_H_
diff --git a/media/server/main/include/MainThread.h b/media/server/main/include/MainThread.h
new file mode 100644
index 0000000..43ce5c7
--- /dev/null
+++ b/media/server/main/include/MainThread.h
@@ -0,0 +1,135 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FIREBOLT_RIALTO_SERVER_MAIN_THREAD_H_
+#define FIREBOLT_RIALTO_SERVER_MAIN_THREAD_H_
+
+#include "IMainThread.h"
+#include <atomic>
+#include <condition_variable>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <queue>
+#include <set>
+#include <string>
+#include <thread>
+
+namespace firebolt::rialto::server
+{
+/**
+ * @brief IMainThread factory class definition.
+ */
+class MainThreadFactory : public IMainThreadFactory
+{
+public:
+    MainThreadFactory() = default;
+    ~MainThreadFactory() override = default;
+
+    std::shared_ptr<IMainThread> getMainThread() const override;
+
+protected:
+    /**
+     * @brief Weak pointer to the singleton main thread object.
+     */
+    static std::weak_ptr<IMainThread> m_mainThread;
+};
+
+/**
+ * @brief The definition of the MediaKeys.
+ */
+class MainThread : public IMainThread
+{
+public:
+    MainThread();
+    virtual ~MainThread();
+
+    int32_t registerClient() override;
+    void unregisterClient(uint32_t clientId) override;
+
+    void enqueueTask(uint32_t clientId, Task task) override;
+    void enqueueTaskAndWait(uint32_t clientId, Task task) override;
+
+private:
+    /**
+     * @brief Information of a task.
+     */
+    struct TaskInfo
+    {
+        uint32_t clientId;                           /**< The id of the client creating the task. */
+        Task task;                                   /**< The task to execute. */
+        std::unique_ptr<std::mutex> mutex;           /**< Mutex for the task condition variable. */
+        std::unique_ptr<std::condition_variable> cv; /**< The condition variable of the task. */
+    };
+
+    /**
+     * @brief Starts a loop that listens for enqueued tasks.
+     */
+    void mainThreadLoop();
+
+    /**
+     * @brief Waits for tasks to enter the queue and returns the next task.
+     *
+     * @retval The next task in the queue.
+     */
+    const std::shared_ptr<TaskInfo> waitForTask();
+
+    /**
+     * @brief Whether the main thread is running.
+     */
+    bool m_isMainThreadRunning;
+
+    /**
+     * @brief The main thread.
+     */
+    std::thread m_thread;
+
+    /**
+     * @brief A mutex protecting access to the task queue.
+     */
+    std::mutex m_taskQueueMutex;
+
+    /**
+     * @brief A condition variable used to notify of tasks entering the task queue.
+     */
+    std::condition_variable m_taskQueueCv;
+
+    /**
+     * @brief The queue of tasks and there infomation.
+     */
+    std::queue<std::shared_ptr<TaskInfo>> m_taskQueue;
+
+    /**
+     * @brief The main thread objects client id, for registering new clients.
+     */
+    const uint32_t m_mainThreadClientId;
+
+    /**
+     * @brief The next client id to be given to a registering client.
+     */
+    std::atomic<uint32_t> m_nextClientId;
+
+    /**
+     * @brief Clients registered on this thread.
+     */
+    std::set<uint32_t> m_registeredClients;
+};
+} // namespace firebolt::rialto::server
+
+#endif // FIREBOLT_RIALTO_SERVER_MAIN_THREAD_H_
diff --git a/media/server/main/include/MediaKeySession.h b/media/server/main/include/MediaKeySession.h
index e7fafbb..a75f825 100644
--- a/media/server/main/include/MediaKeySession.h
+++ b/media/server/main/include/MediaKeySession.h
@@ -20,6 +20,7 @@
 #ifndef FIREBOLT_RIALTO_SERVER_MEDIA_KEY_SESSION_H_
 #define FIREBOLT_RIALTO_SERVER_MEDIA_KEY_SESSION_H_
 
+#include "IMainThread.h"
 #include "IMediaKeySession.h"
 #include "IOcdmSessionClient.h"
 #include <atomic>
@@ -53,15 +54,17 @@ public:
     /**
      * @brief The constructor.
      *
-     * @param[in]  keySystem    : The key system for this session.
-     * @param[in]  keySessionId : The key session id for this session.
-     * @param[in]  ocdmSystem   : The ocdm system object to create the session on.
-     * @param[in]  sessionType  : The session type.
-     * @param[in]  client       : Client object for callbacks.
-     * @param[in]  isLDL        : Is this an LDL.
+     * @param[in]  keySystem            : The key system for this session.
+     * @param[in]  keySessionId         : The key session id for this session.
+     * @param[in]  ocdmSystem           : The ocdm system object to create the session on.
+     * @param[in]  sessionType          : The session type.
+     * @param[in]  client               : Client object for callbacks.
+     * @param[in]  isLDL                : Is this an LDL.
+     * @param[in]  mainThreadFactory    : The main thread factory.
      */
     MediaKeySession(const std::string &keySystem, int32_t keySessionId, const IOcdmSystem &ocdmSystem,
-                    KeySessionType sessionType, std::weak_ptr<IMediaKeysClient> client, bool isLDL);
+                    KeySessionType sessionType, std::weak_ptr<IMediaKeysClient> client, bool isLDL,
+                    const std::shared_ptr<IMainThreadFactory> &mainThreadFactory);
 
     /**
      * @brief Virtual destructor.
@@ -95,17 +98,17 @@ private:
     /**
      * @brief KeySystem type of the MediaKeys.
      */
-    const std::string m_keySystem;
+    const std::string m_kKeySystem;
 
     /**
      * @brief The key session id for this session.
      */
-    const int32_t m_keySessionId;
+    const int32_t m_kKeySessionId;
 
     /**
      * @brief The key session type of this session.
      */
-    const KeySessionType m_sessionType;
+    const KeySessionType m_kSessionType;
 
     /**
      * @brief The media keys client object.
@@ -117,10 +120,15 @@ private:
      */
     std::unique_ptr<IOcdmSession> m_ocdmSession;
 
+    /**
+     * @brief The mainThread object.
+     */
+    std::shared_ptr<IMainThread> m_mainThread;
+
     /**
      * @brief Is the session LDL.
      */
-    const bool m_isLDL;
+    const bool m_kIsLDL;
 
     /**
      * @brief Is the ocdm session constructed.
@@ -136,6 +144,18 @@ private:
      * @brief Store of the updated key statuses from a onKeyUpdated.
      */
     KeyStatusVector m_updatedKeyStatuses;
+
+    /**
+     * @brief This objects id registered on the main thread
+     */
+    uint32_t m_mainThreadClientId;
+
+    /**
+     * @brief Posts a getChallenge task onto the main thread.
+     *
+     * The challenge data is retrieved from ocdm and notified on a onLicenseRequest.
+     */
+    void getChallenge();
 };
 } // namespace firebolt::rialto::server
 
diff --git a/media/server/main/include/MediaKeysServerInternal.h b/media/server/main/include/MediaKeysServerInternal.h
index 1462748..2f80b14 100644
--- a/media/server/main/include/MediaKeysServerInternal.h
+++ b/media/server/main/include/MediaKeysServerInternal.h
@@ -20,6 +20,7 @@
 #ifndef FIREBOLT_RIALTO_SERVER_MEDIA_KEYS_SERVER_INTERNAL_H_
 #define FIREBOLT_RIALTO_SERVER_MEDIA_KEYS_SERVER_INTERNAL_H_
 
+#include "IMainThread.h"
 #include "IMediaKeySession.h"
 #include "IMediaKeysServerInternal.h"
 #include "IOcdmSystem.h"
@@ -57,11 +58,13 @@ public:
      * @brief The constructor.
      *
      * @param[in] keySystem                 : The key system for which to create a Media Keys instance.
+     * @param[in] mainThreadFactory         : The main thread factory.
      * @param[in] ocdmSystemFactory         : The ocdm system factory.
      * @param[in] mediaKeySessionFactory    : The media key session factory.
      *
      */
-    MediaKeysServerInternal(const std::string &keySystem, std::shared_ptr<IOcdmSystemFactory> ocdmSystemFactory,
+    MediaKeysServerInternal(const std::string &keySystem, const std::shared_ptr<IMainThreadFactory> &mainThreadFactory,
+                            std::shared_ptr<IOcdmSystemFactory> ocdmSystemFactory,
                             std::shared_ptr<IMediaKeySessionFactory> mediaKeySessionFactory);
 
     /**
@@ -112,6 +115,11 @@ public:
     bool hasSession(int32_t keySessionId) const override;
 
 private:
+    /**
+     * @brief The mainThread object.
+     */
+    std::shared_ptr<IMainThread> m_mainThread;
+
     /**
      * @brief The factory for creating MediaKeySessions.
      */
@@ -131,6 +139,93 @@ private:
      * @brief KeySystem type of the MediaKeysServerInternal.
      */
     const std::string m_keySystem;
+
+    /**
+     * @brief This objects id registered on the main thread
+     */
+    uint32_t m_mainThreadClientId;
+
+    /**
+     * @brief Creates a session internally, only to be called on the main thread.
+     *
+     * @param[in]  sessionType : The session type.
+     * @param[in]  client      : Client object for callbacks
+     * @param[in]  isLDL       : Is this an LDL
+     * @param[out] keySessionId: The key session id
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus createKeySessionInternal(KeySessionType sessionType, std::weak_ptr<IMediaKeysClient> client,
+                                                 bool isLDL, int32_t &keySessionId);
+
+    /**
+     * @brief Generate internally, only to be called on the main thread.
+     *
+     * @param[in]  keySessionId : The key session id for the session.
+     * @param[in]  initDataType : The init data type.
+     * @param[in]  initData     : The init data.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus generateRequestInternal(int32_t keySessionId, InitDataType initDataType,
+                                                const std::vector<uint8_t> &initData);
+
+    /**
+     * @brief Load internally, only to be called on the main thread.
+     *
+     * @param[in] keySessionId : The key session id for the session.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus loadSessionInternal(int32_t keySessionId);
+
+    /**
+     * @brief Update internally, only to be called on the main thread.
+     *
+     * @param[in] keySessionId : The key session id for the session.
+     * @param[in] responseData : The license response data.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus updateSessionInternal(int32_t keySessionId, const std::vector<uint8_t> &responseData);
+
+    /**
+     * @brief Close a key session internally, only to be called on the main thread.
+     *
+     * @param[in] keySessionId : The key session id.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus closeKeySessionInternal(int32_t keySessionId);
+
+    /**
+     * @brief Removes a key session internally, only to be called on the main thread.
+     *
+     * @param[in] keySessionId : The key session id.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus removeKeySessionInternal(int32_t keySessionId);
+
+    /**
+     * @brief Decrypt internally, only to be called on the main thread.
+     *
+     * @param[in] keySessionId    : The session id for the session.
+     * @param[in]  encrypted      : Gstreamer buffer containing encrypted data and related meta data. If applicable,
+     *                              decrypted data will be stored here after this call returns.
+     * @param[in]  subSample      : Gstreamer buffer containing subsamples size which has been parsed from protection
+     *                              meta data.
+     * @param[in]  subSampleCount : count of subsamples
+     * @param[in]  IV             : Gstreamer buffer containing initial vector (IV) used during decryption.
+     * @param[in]  keyId          : Gstreamer buffer containing keyID to use for decryption
+     * @param[in]  initWithLast15 : The value deciding whether decryption context needs to be initialized with
+     *                              last 15 bytes. Currently this only applies to PlayReady DRM.
+     *
+     * @retval an error status.
+     */
+    MediaKeyErrorStatus decryptInternal(int32_t keySessionId, GstBuffer *encrypted, GstBuffer *subSample,
+                                        const uint32_t subSampleCount, GstBuffer *IV, GstBuffer *keyId,
+                                        uint32_t initWithLast15);
 };
 
 }; // namespace firebolt::rialto::server
diff --git a/media/server/main/include/MediaPipelineServerInternal.h b/media/server/main/include/MediaPipelineServerInternal.h
index e26eda1..63c16b2 100644
--- a/media/server/main/include/MediaPipelineServerInternal.h
+++ b/media/server/main/include/MediaPipelineServerInternal.h
@@ -23,6 +23,7 @@
 #include "DataReaderFactory.h"
 #include "IActiveRequests.h"
 #include "IGstPlayer.h"
+#include "IMainThread.h"
 #include "IMediaPipelineServerInternal.h"
 #include <memory>
 #include <string>
@@ -70,6 +71,7 @@ public:
      * @param[in] gstPlayerFactory  : The gstreamer player factory.
      * @param[in] sessionId         : The session id
      * @param[in] shmBuffer         : The shared memory buffer
+     * @param[in] mainThreadFactory : The main thread factory.
      * @param[in] dataReaderFactory : The data reader factory
      * @param[in] activeRequests    : The active requests
      * @param[in] decryptionService : The decryption service
@@ -77,6 +79,7 @@ public:
     MediaPipelineServerInternal(std::shared_ptr<IMediaPipelineClient> client, const VideoRequirements &videoRequirements,
                                 const std::shared_ptr<IGstPlayerFactory> &gstPlayerFactory, int sessionId,
                                 const std::shared_ptr<ISharedMemoryBuffer> &shmBuffer,
+                                const std::shared_ptr<IMainThreadFactory> &mainThreadFactory,
                                 std::unique_ptr<IDataReaderFactory> &&dataReaderFactory,
                                 std::unique_ptr<IActiveRequests> &&activeRequests, IDecryptionService &decryptionService);
 
@@ -133,6 +136,11 @@ protected:
      */
     std::shared_ptr<IMediaPipelineClient> m_mediaPipelineClient;
 
+    /**
+     * @brief The mainThread object.
+     */
+    std::shared_ptr<IMainThread> m_mainThread;
+
     /**
      * @brief The gstreamer player factory object.
      */
@@ -168,10 +176,133 @@ protected:
      */
     std::unique_ptr<IActiveRequests> m_activeRequests;
 
+    /**
+     * @brief This objects id registered on the main thread
+     */
+    uint32_t m_mainThreadClientId;
+
     /**
      * @brief Decryption service
      */
     IDecryptionService &m_decryptionService;
+
+    /**
+     * @brief Load internally, only to be called on the main thread.
+     *
+     * @param[in] type     : The media type.
+     * @param[in] mimeType : The MIME type.
+     * @param[in] url      : The URL.
+     *
+     * @retval true on success.
+     */
+    bool loadInternal(MediaType type, const std::string &mimeType, const std::string &url);
+
+    /**
+     * @brief Attach source internally, only to be called on the main thread.
+     *
+     * @param[in] source : The source.
+     *
+     * @retval true on success.
+     */
+    bool attachSourceInternal(MediaSource &source);
+
+    /**
+     * @brief Play internally, only to be called on the main thread.
+     *
+     * @retval true on success.
+     */
+    bool playInternal();
+
+    /**
+     * @brief Pause internally, only to be called on the main thread.
+     *
+     * @retval true on success.
+     */
+    bool pauseInternal();
+
+    /**
+     * @brief Stop internally, only to be called on the main thread.
+     *
+     * @retval true on success.
+     */
+    bool stopInternal();
+
+    /**
+     * @brief Set the playback rate internally, only to be called on the main thread.
+     *
+     * @param[in] rate : The playback rate.
+     *
+     * @retval true on success.
+     */
+    bool setPlaybackRateInternal(double rate);
+
+    /**
+     * @brief Set the position internally, only to be called on the main thread.
+     *
+     * @param[in] position : The playback position in nanoseconds.
+     *
+     * @retval true on success.
+     */
+    bool setPositionInternal(int64_t position);
+
+    /**
+     * @brief Get position internally, only to be called on the main thread.
+     *
+     * @param[out] position : The playback position in nanoseconds
+     *
+     * @retval true on success.
+     */
+    bool getPositionInternal(int64_t &position);
+
+    /**
+     * @brief Set video window internally, only to be called on the main thread.
+     *
+     * @param[in] x      : The x position in pixels.
+     * @param[in] y      : The y position in pixels.
+     * @param[in] width  : The width in pixels.
+     * @param[in] height : The height in pixels.
+     *
+     * @retval true on success.
+     */
+    bool setVideoWindowInternal(uint32_t x, uint32_t y, uint32_t width, uint32_t height);
+
+    /**
+     * @brief Have data internally, only to be called on the main thread.
+     *
+     * @param[in] status : The status
+     * @param[in] needDataRequestId : Need data request id
+     *
+     * @retval true on success.
+     */
+    bool haveDataInternal(MediaSourceStatus status, uint32_t needDataRequestId);
+
+    /**
+     * @brief Have data internally, only to be called on the main thread.
+     *
+     * @param[in] status            : The status
+     * @param[in] numFrames         : The number of frames written.
+     * @param[in] needDataRequestId : Need data request id
+     *
+     * @retval true on success.
+     */
+    bool haveDataInternal(MediaSourceStatus status, uint32_t numFrames, uint32_t needDataRequestId);
+
+    /**
+     * @brief Add segment internally, only to be called on the main thread.
+     *
+     * @param[in] needDataRequestId : The status
+     * @param[in] mediaSegment : The data returned.
+     *
+     * @retval status of adding segment
+     */
+    AddSegmentStatus addSegmentInternal(uint32_t needDataRequestId, const std::unique_ptr<MediaSegment> &mediaSegment);
+
+    /**
+     * @brief Notify need media data internally, only to be called on the main thread.
+     *
+     * @param[in] mediaSourceType    : The media source type.
+     */
+    bool notifyNeedMediaDataInternal(MediaSourceType mediaSourceType);
 };
 
 }; // namespace firebolt::rialto::server
diff --git a/media/server/main/public/IMediaPipelineServerInternal.h b/media/server/main/public/IMediaPipelineServerInternal.h
index 956a277..5406c70 100644
--- a/media/server/main/public/IMediaPipelineServerInternal.h
+++ b/media/server/main/public/IMediaPipelineServerInternal.h
@@ -63,6 +63,8 @@ public:
      *
      * @param[in] client            : The Rialto media player client.
      * @param[in] videoRequirements : The video decoder requirements for the MediaPipeline session
+     * @param[in] sessionId         : The session id for this MediaPipeline.
+     * @param[in] shmBuffer         : The shared buffer object.
      *
      * @retval the new backend instance or null on error.
      */
diff --git a/media/server/main/source/MainThread.cpp b/media/server/main/source/MainThread.cpp
new file mode 100644
index 0000000..dfe8438
--- /dev/null
+++ b/media/server/main/source/MainThread.cpp
@@ -0,0 +1,164 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "MainThread.h"
+#include "RialtoServerLogging.h"
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace firebolt::rialto::server
+{
+std::weak_ptr<IMainThread> MainThreadFactory::m_mainThread;
+
+std::shared_ptr<IMainThreadFactory> IMainThreadFactory::createFactory()
+{
+    std::shared_ptr<IMainThreadFactory> factory;
+    try
+    {
+        factory = std::make_shared<MainThreadFactory>();
+    }
+    catch (const std::exception &e)
+    {
+        RIALTO_SERVER_LOG_ERROR("Failed to create the main thread factory, reason: %s", e.what());
+    }
+
+    return factory;
+}
+
+std::shared_ptr<IMainThread> MainThreadFactory::getMainThread() const
+{
+    std::shared_ptr<IMainThread> mainThread = m_mainThread.lock();
+    if (!mainThread)
+    {
+        try
+        {
+            mainThread = std::make_shared<MainThread>();
+        }
+        catch (const std::exception &e)
+        {
+            RIALTO_SERVER_LOG_ERROR("Failed to create the main thread, reason: %s", e.what());
+        }
+
+        m_mainThread = mainThread;
+    }
+
+    return mainThread;
+}
+
+MainThread::MainThread() : m_isMainThreadRunning{true}, m_mainThreadClientId{0}, m_nextClientId{1}
+{
+    RIALTO_SERVER_LOG_DEBUG("MainThread is constructed");
+    m_thread = std::thread(std::bind(&MainThread::mainThreadLoop, this));
+
+    // Register itself
+    m_registeredClients.insert(m_mainThreadClientId);
+}
+
+MainThread::~MainThread()
+{
+    RIALTO_SERVER_LOG_DEBUG("MainThread is destructed");
+    auto shutdownTask = [this]() { m_isMainThreadRunning = false; };
+    enqueueTask(m_mainThreadClientId, shutdownTask);
+    m_thread.join();
+}
+
+void MainThread::mainThreadLoop()
+{
+    while (m_isMainThreadRunning)
+    {
+        const std::shared_ptr<TaskInfo> taskInfo = waitForTask();
+        if (m_registeredClients.find(taskInfo->clientId) != m_registeredClients.end())
+        {
+            taskInfo->task();
+        }
+        else
+        {
+            RIALTO_SERVER_LOG_WARN("Task ignored, client '%d' not registered", taskInfo->clientId);
+        }
+
+        if (nullptr != taskInfo->cv)
+            taskInfo->cv->notify_one();
+    }
+}
+
+const std::shared_ptr<MainThread::TaskInfo> MainThread::waitForTask()
+{
+    std::unique_lock<std::mutex> lock(m_taskQueueMutex);
+    if (m_taskQueue.empty())
+    {
+        m_taskQueueCv.wait(lock, [this] { return !m_taskQueue.empty(); });
+    }
+    const std::shared_ptr<TaskInfo> taskInfo = m_taskQueue.front();
+    m_taskQueue.pop();
+    return taskInfo;
+}
+
+int32_t MainThread::registerClient()
+{
+    uint32_t clientId = m_nextClientId++;
+
+    auto task = [&, clientId]() {
+        RIALTO_SERVER_LOG_INFO("Registering client '%u'", clientId);
+        m_registeredClients.insert(clientId);
+    };
+    enqueueTask(m_mainThreadClientId, task);
+
+    return clientId;
+}
+
+void MainThread::unregisterClient(uint32_t clientId)
+{
+    RIALTO_SERVER_LOG_INFO("Unregistering client '%u'", clientId);
+    m_registeredClients.erase(clientId);
+}
+
+void MainThread::enqueueTask(uint32_t clientId, Task task)
+{
+    std::shared_ptr<TaskInfo> newTask = std::make_shared<TaskInfo>();
+    newTask->clientId = clientId;
+    newTask->task = task;
+    {
+        std::unique_lock<std::mutex> lock(m_taskQueueMutex);
+        m_taskQueue.push(newTask);
+    }
+    m_taskQueueCv.notify_one();
+}
+
+void MainThread::enqueueTaskAndWait(uint32_t clientId, Task task)
+{
+    std::shared_ptr<TaskInfo> newTask = std::make_shared<TaskInfo>();
+    newTask->clientId = clientId;
+    newTask->task = task;
+    newTask->mutex = std::make_unique<std::mutex>();
+    newTask->cv = std::make_unique<std::condition_variable>();
+
+    {
+        std::unique_lock<std::mutex> lockTask(*(newTask->mutex));
+        {
+            std::unique_lock<std::mutex> lockQueue(m_taskQueueMutex);
+            m_taskQueue.push(newTask);
+        }
+        m_taskQueueCv.notify_one();
+
+        newTask->cv->wait(lockTask);
+    }
+}
+
+} // namespace firebolt::rialto::server
diff --git a/media/server/main/source/MediaKeySession.cpp b/media/server/main/source/MediaKeySession.cpp
index dad0257..649ddd8 100644
--- a/media/server/main/source/MediaKeySession.cpp
+++ b/media/server/main/source/MediaKeySession.cpp
@@ -47,8 +47,8 @@ MediaKeySessionFactory::createMediaKeySession(const std::string &keySystem, int3
     std::unique_ptr<IMediaKeySession> mediaKeys;
     try
     {
-        mediaKeys =
-            std::make_unique<server::MediaKeySession>(keySystem, keySessionId, ocdmSystem, sessionType, client, isLDL);
+        mediaKeys = std::make_unique<server::MediaKeySession>(keySystem, keySessionId, ocdmSystem, sessionType, client,
+                                                              isLDL, server::IMainThreadFactory::createFactory());
     }
     catch (const std::exception &e)
     {
@@ -59,12 +59,20 @@ MediaKeySessionFactory::createMediaKeySession(const std::string &keySystem, int3
 }
 
 MediaKeySession::MediaKeySession(const std::string &keySystem, int32_t keySessionId, const IOcdmSystem &ocdmSystem,
-                                 KeySessionType sessionType, std::weak_ptr<IMediaKeysClient> client, bool isLDL)
-    : m_keySystem(keySystem), m_keySessionId(keySessionId), m_sessionType(sessionType), m_mediaKeysClient(client),
-      m_isLDL(isLDL), m_isSessionConstructed(false), m_licenseRequested(false)
+                                 KeySessionType sessionType, std::weak_ptr<IMediaKeysClient> client, bool isLDL,
+                                 const std::shared_ptr<IMainThreadFactory> &mainThreadFactory)
+    : m_kKeySystem(keySystem), m_kKeySessionId(keySessionId), m_kSessionType(sessionType), m_mediaKeysClient(client),
+      m_kIsLDL(isLDL), m_isSessionConstructed(false), m_licenseRequested(false)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    m_mainThread = mainThreadFactory->getMainThread();
+    if (!m_mainThread)
+    {
+        throw std::runtime_error("Failed to get the main thread");
+    }
+    m_mainThreadClientId = m_mainThread->registerClient();
+
     m_ocdmSession = ocdmSystem.createSession(this);
     if (!m_ocdmSession)
     {
@@ -80,21 +88,20 @@ MediaKeySession::~MediaKeySession()
     {
         static_cast<void>(closeKeySession());
     }
+
+    m_mainThread->unregisterClient(m_mainThreadClientId);
 }
 
 MediaKeyErrorStatus MediaKeySession::generateRequest(InitDataType initDataType, const std::vector<uint8_t> &initData)
 {
+    // Set the request flag for the onLicenseRequest callback
+    m_licenseRequested = true;
+
+    // Only construct session if it hasnt previously been constructed
     if (!m_isSessionConstructed)
     {
-        // Ocdm can send the challenge before constructSession completes, set the request flag
-        if (kNetflixKeySystem != m_keySystem)
-        {
-            m_licenseRequested = true;
-        }
-
-        // Only construct session if it hasnt previously been constructed
         MediaKeyErrorStatus status =
-            m_ocdmSession->constructSession(m_sessionType, initDataType, &initData[0], initData.size());
+            m_ocdmSession->constructSession(m_kSessionType, initDataType, &initData[0], initData.size());
         if (MediaKeyErrorStatus::OK != status)
         {
             RIALTO_SERVER_LOG_ERROR("Failed to construct the key session");
@@ -103,14 +110,47 @@ MediaKeyErrorStatus MediaKeySession::generateRequest(InitDataType initDataType,
         else
         {
             m_isSessionConstructed = true;
+            if (kNetflixKeySystem == m_kKeySystem)
+            {
+                // Ocdm-playready netflix does not notify onProcessChallenge when complete.
+                // Fetch the challenge manually.
+                getChallenge();
+            }
         }
         return status;
     }
+    else
+    {
+        // Get the challenge manually and notify onLicenseRequest
+        getChallenge();
+    }
 
-    // TODO(LLDEV-31226): If the session had already been constructed or the key system is Netflix
-    // the challenge has to be fetched manually after generateRequest.
+    return MediaKeyErrorStatus::OK;
+}
 
-    return MediaKeyErrorStatus::FAIL;
+void MediaKeySession::getChallenge()
+{
+    auto task = [&]() {
+        uint32_t challengeSize = 0;
+        MediaKeyErrorStatus status = m_ocdmSession->getChallengeData(m_kIsLDL, nullptr, &challengeSize);
+        if (MediaKeyErrorStatus::OK != status)
+        {
+            RIALTO_SERVER_LOG_ERROR("Failed to get the challenge data, no onLicenseRequest will be generated");
+            return;
+        }
+
+        std::vector<uint8_t> challenge(challengeSize);
+        status = m_ocdmSession->getChallengeData(m_kIsLDL, &challenge[0], &challengeSize);
+        if (MediaKeyErrorStatus::OK != status)
+        {
+            RIALTO_SERVER_LOG_ERROR("Failed to get the challenge data, no onLicenseRequest will be generated");
+            return;
+        }
+
+        std::string url;
+        onProcessChallenge(url.c_str(), &challenge[0], challengeSize);
+    };
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 MediaKeyErrorStatus MediaKeySession::loadSession()
@@ -126,7 +166,7 @@ MediaKeyErrorStatus MediaKeySession::loadSession()
 MediaKeyErrorStatus MediaKeySession::updateSession(const std::vector<uint8_t> &responseData)
 {
     MediaKeyErrorStatus status;
-    if (kNetflixKeySystem == m_keySystem)
+    if (kNetflixKeySystem == m_kKeySystem)
     {
         status = m_ocdmSession->storeLicenseData(&responseData[0], responseData.size());
         if (MediaKeyErrorStatus::OK != status)
@@ -160,7 +200,7 @@ MediaKeyErrorStatus MediaKeySession::decrypt(GstBuffer *encrypted, GstBuffer *su
 MediaKeyErrorStatus MediaKeySession::closeKeySession()
 {
     MediaKeyErrorStatus status;
-    if (kNetflixKeySystem == m_keySystem)
+    if (kNetflixKeySystem == m_kKeySystem)
     {
         status = m_ocdmSession->cancelChallengeData();
         if (MediaKeyErrorStatus::OK != status)
@@ -225,44 +265,51 @@ MediaKeyErrorStatus MediaKeySession::getCdmKeySessionId(std::string &cdmKeySessi
 
 void MediaKeySession::onProcessChallenge(const char url[], const uint8_t challenge[], const uint16_t challengeLength)
 {
-    // TODO(LLDEV-31226) Post onto main thread
-    std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
-    if (client)
-    {
-        if (m_licenseRequested)
+    std::string urlStr = url;
+    std::vector<unsigned char> challengeVec = std::vector<unsigned char>{challenge, challenge + challengeLength};
+    auto task = [&, urlStr, challengeVec]() {
+        std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
+        if (client)
         {
-            std::string urlStr = url;
-            client->onLicenseRequest(m_keySessionId, std::vector<unsigned char>{challenge, challenge + challengeLength},
-                                     urlStr);
-            m_licenseRequested = false;
+            if (m_licenseRequested)
+            {
+                client->onLicenseRequest(m_kKeySessionId, challengeVec, urlStr);
+                m_licenseRequested = false;
+            }
+            else
+            {
+                client->onLicenseRenewal(m_kKeySessionId, challengeVec);
+            }
         }
-        else
-        {
-            client->onLicenseRenewal(m_keySessionId, std::vector<unsigned char>{challenge, challenge + challengeLength});
-        }
-    }
+    };
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaKeySession::onKeyUpdated(const uint8_t keyId[], const uint8_t keyIdLength)
 {
-    // TODO(LLDEV-31226) Post onto main thread
-    std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
-    if (client)
-    {
-        KeyStatus status = m_ocdmSession->getStatus(keyId, keyIdLength);
-        m_updatedKeyStatuses.push_back(std::make_pair(std::vector<unsigned char>{keyId, keyId + keyIdLength}, status));
-    }
+    std::vector<unsigned char> keyIdVec = std::vector<unsigned char>{keyId, keyId + keyIdLength};
+    auto task = [&, keyIdVec]() {
+        std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
+        if (client)
+        {
+            KeyStatus status = m_ocdmSession->getStatus(&keyIdVec[0], keyIdVec.size());
+            m_updatedKeyStatuses.push_back(std::make_pair(keyIdVec, status));
+        }
+    };
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaKeySession::onAllKeysUpdated()
 {
-    // TODO(LLDEV-31226) Post onto main thread
-    std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
-    if (client)
-    {
-        client->onKeyStatusesChanged(m_keySessionId, m_updatedKeyStatuses);
-        m_updatedKeyStatuses.clear();
-    }
+    auto task = [&]() {
+        std::shared_ptr<IMediaKeysClient> client = m_mediaKeysClient.lock();
+        if (client)
+        {
+            client->onKeyStatusesChanged(m_kKeySessionId, m_updatedKeyStatuses);
+            m_updatedKeyStatuses.clear();
+        }
+    };
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaKeySession::onError(const char message[])
diff --git a/media/server/main/source/MediaKeysServerInternal.cpp b/media/server/main/source/MediaKeysServerInternal.cpp
index a79be23..bd44b91 100644
--- a/media/server/main/source/MediaKeysServerInternal.cpp
+++ b/media/server/main/source/MediaKeysServerInternal.cpp
@@ -65,6 +65,7 @@ MediaKeysServerInternalFactory::createMediaKeysServerInternal(const std::string
     try
     {
         mediaKeys = std::make_unique<server::MediaKeysServerInternal>(keySystem,
+                                                                      server::IMainThreadFactory::createFactory(),
                                                                       server::IOcdmSystemFactory::createFactory(),
                                                                       server::IMediaKeySessionFactory::createFactory());
     }
@@ -80,22 +81,51 @@ MediaKeysServerInternalFactory::createMediaKeysServerInternal(const std::string
 namespace firebolt::rialto::server
 {
 MediaKeysServerInternal::MediaKeysServerInternal(const std::string &keySystem,
+                                                 const std::shared_ptr<IMainThreadFactory> &mainThreadFactory,
                                                  std::shared_ptr<IOcdmSystemFactory> ocdmSystemFactory,
                                                  std::shared_ptr<IMediaKeySessionFactory> mediaKeySessionFactory)
     : m_mediaKeySessionFactory(mediaKeySessionFactory), m_keySystem(keySystem)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
-    m_ocdmSystem = ocdmSystemFactory->createOcdmSystem(keySystem);
-    if (!m_ocdmSystem)
+    m_mainThread = mainThreadFactory->getMainThread();
+    if (!m_mainThread)
     {
-        throw std::runtime_error("Ocdm system could not be created");
+        throw std::runtime_error("Failed to get the main thread");
+    }
+    m_mainThreadClientId = m_mainThread->registerClient();
+
+    bool result = false;
+    auto task = [&]() {
+        m_ocdmSystem = ocdmSystemFactory->createOcdmSystem(keySystem);
+        if (!m_ocdmSystem)
+        {
+            RIALTO_SERVER_LOG_ERROR("Ocdm system could not be created");
+        }
+        else
+        {
+            result = true;
+        }
+    };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    if (!result)
+    {
+        throw std::runtime_error("MediaKeys construction failed");
     }
 }
 
 MediaKeysServerInternal::~MediaKeysServerInternal()
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    auto task = [&]() {
+        m_ocdmSystem.reset();
+
+        m_mainThread->unregisterClient(m_mainThreadClientId);
+    };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
 }
 
 MediaKeyErrorStatus MediaKeysServerInternal::selectKeyId(int32_t keySessionId, const std::vector<uint8_t> &keyId)
@@ -118,6 +148,17 @@ MediaKeyErrorStatus MediaKeysServerInternal::createKeySession(KeySessionType ses
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = createKeySessionInternal(sessionType, client, isLDL, keySessionId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::createKeySessionInternal(KeySessionType sessionType,
+                                                                      std::weak_ptr<IMediaKeysClient> client,
+                                                                      bool isLDL, int32_t &keySessionId)
+{
     int32_t keySessionIdTemp = generateSessionId();
     std::unique_ptr<IMediaKeySession> mediaKeySession =
         m_mediaKeySessionFactory->createMediaKeySession(m_keySystem, keySessionIdTemp, *m_ocdmSystem, sessionType,
@@ -138,6 +179,16 @@ MediaKeyErrorStatus MediaKeysServerInternal::generateRequest(int32_t keySessionI
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = generateRequestInternal(keySessionId, initDataType, initData); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::generateRequestInternal(int32_t keySessionId, InitDataType initDataType,
+                                                                     const std::vector<uint8_t> &initData)
+{
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
     {
@@ -151,7 +202,6 @@ MediaKeyErrorStatus MediaKeysServerInternal::generateRequest(int32_t keySessionI
         RIALTO_SERVER_LOG_ERROR("Failed to generate request for the key session");
         return status;
     }
-
     return status;
 }
 
@@ -159,6 +209,15 @@ MediaKeyErrorStatus MediaKeysServerInternal::loadSession(int32_t keySessionId)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = loadSessionInternal(keySessionId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::loadSessionInternal(int32_t keySessionId)
+{
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
     {
@@ -172,7 +231,6 @@ MediaKeyErrorStatus MediaKeysServerInternal::loadSession(int32_t keySessionId)
         RIALTO_SERVER_LOG_ERROR("Failed to load the session");
         return status;
     }
-
     return status;
 }
 
@@ -180,6 +238,16 @@ MediaKeyErrorStatus MediaKeysServerInternal::updateSession(int32_t keySessionId,
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = updateSessionInternal(keySessionId, responseData); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::updateSessionInternal(int32_t keySessionId,
+                                                                   const std::vector<uint8_t> &responseData)
+{
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
     {
@@ -193,7 +261,6 @@ MediaKeyErrorStatus MediaKeysServerInternal::updateSession(int32_t keySessionId,
         RIALTO_SERVER_LOG_ERROR("Failed to update the session");
         return status;
     }
-
     return status;
 }
 
@@ -208,6 +275,15 @@ MediaKeyErrorStatus MediaKeysServerInternal::closeKeySession(int32_t keySessionI
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = closeKeySessionInternal(keySessionId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::closeKeySessionInternal(int32_t keySessionId)
+{
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
     {
@@ -221,9 +297,7 @@ MediaKeyErrorStatus MediaKeysServerInternal::closeKeySession(int32_t keySessionI
         RIALTO_SERVER_LOG_ERROR("Failed to close the key session");
         return status;
     }
-
     m_mediaKeySessions.erase(sessionIter);
-
     return status;
 }
 
@@ -231,6 +305,15 @@ MediaKeyErrorStatus MediaKeysServerInternal::removeKeySession(int32_t keySession
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
+    MediaKeyErrorStatus status;
+    auto task = [&]() { status = removeKeySessionInternal(keySessionId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::removeKeySessionInternal(int32_t keySessionId)
+{
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
     {
@@ -244,7 +327,6 @@ MediaKeyErrorStatus MediaKeysServerInternal::removeKeySession(int32_t keySession
         RIALTO_SERVER_LOG_ERROR("Failed to remove the key session");
         return status;
     }
-
     return status;
 }
 
@@ -321,6 +403,21 @@ MediaKeyErrorStatus MediaKeysServerInternal::getCdmKeySessionId(int32_t keySessi
 MediaKeyErrorStatus MediaKeysServerInternal::decrypt(int32_t keySessionId, GstBuffer *encrypted, GstBuffer *subSample,
                                                      const uint32_t subSampleCount, GstBuffer *IV, GstBuffer *keyId,
                                                      uint32_t initWithLast15)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    MediaKeyErrorStatus status;
+    auto task = [&]() {
+        status = decryptInternal(keySessionId, encrypted, subSample, subSampleCount, IV, keyId, initWithLast15);
+    };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+MediaKeyErrorStatus MediaKeysServerInternal::decryptInternal(int32_t keySessionId, GstBuffer *encrypted,
+                                                             GstBuffer *subSample, const uint32_t subSampleCount,
+                                                             GstBuffer *IV, GstBuffer *keyId, uint32_t initWithLast15)
 {
     auto sessionIter = m_mediaKeySessions.find(keySessionId);
     if (sessionIter == m_mediaKeySessions.end())
diff --git a/media/server/main/source/MediaPipelineServerInternal.cpp b/media/server/main/source/MediaPipelineServerInternal.cpp
index a47bd6d..fae290e 100644
--- a/media/server/main/source/MediaPipelineServerInternal.cpp
+++ b/media/server/main/source/MediaPipelineServerInternal.cpp
@@ -104,7 +104,8 @@ std::unique_ptr<server::IMediaPipelineServerInternal> MediaPipelineServerInterna
         mediaPipeline =
             std::make_unique<server::MediaPipelineServerInternal>(sharedClient, videoRequirements,
                                                                   server::IGstPlayerFactory::getFactory(), sessionId,
-                                                                  shmBuffer, std::make_unique<DataReaderFactory>(),
+                                                                  shmBuffer, server::IMainThreadFactory::createFactory(),
+                                                                  std::make_unique<DataReaderFactory>(),
                                                                   std::make_unique<ActiveRequests>(), decryptionService);
     }
     catch (const std::exception &e)
@@ -118,24 +119,55 @@ std::unique_ptr<server::IMediaPipelineServerInternal> MediaPipelineServerInterna
 MediaPipelineServerInternal::MediaPipelineServerInternal(
     std::shared_ptr<IMediaPipelineClient> client, const VideoRequirements &videoRequirements,
     const std::shared_ptr<IGstPlayerFactory> &gstPlayerFactory, int sessionId,
-    const std::shared_ptr<ISharedMemoryBuffer> &shmBuffer, std::unique_ptr<IDataReaderFactory> &&dataReaderFactory,
-    std::unique_ptr<IActiveRequests> &&activeRequests, IDecryptionService &decryptionService)
+    const std::shared_ptr<ISharedMemoryBuffer> &shmBuffer, const std::shared_ptr<IMainThreadFactory> &mainThreadFactory,
+    std::unique_ptr<IDataReaderFactory> &&dataReaderFactory, std::unique_ptr<IActiveRequests> &&activeRequests,
+    IDecryptionService &decryptionService)
     : m_mediaPipelineClient(client), m_kGstPlayerFactory(gstPlayerFactory), m_kVideoRequirements(videoRequirements),
       m_sessionId{sessionId}, m_shmBuffer{shmBuffer}, m_dataReaderFactory{std::move(dataReaderFactory)},
       m_activeRequests{std::move(activeRequests)}, m_decryptionService{decryptionService}
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
-    if (!m_shmBuffer->mapPartition(m_sessionId))
+
+    m_mainThread = mainThreadFactory->getMainThread();
+    if (!m_mainThread)
+    {
+        throw std::runtime_error("Failed to get the main thread");
+    }
+    m_mainThreadClientId = m_mainThread->registerClient();
+
+    bool result = false;
+    auto task = [&]() {
+        if (!m_shmBuffer->mapPartition(m_sessionId))
+        {
+            RIALTO_SERVER_LOG_ERROR("Unable to map shm partition");
+        }
+        else
+        {
+            result = true;
+        }
+    };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    if (!result)
     {
-        RIALTO_SERVER_LOG_ERROR("Unable to create a session with id: %d. Unable to map shm partition.", m_sessionId);
-        throw std::runtime_error("Unable to map partition");
+        throw std::runtime_error("MediaPipelineServerInternal construction failed");
     }
 }
 
 MediaPipelineServerInternal::~MediaPipelineServerInternal()
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
-    m_shmBuffer->unmapPartition(m_sessionId);
+
+    auto task = [&]() {
+        if (!m_shmBuffer->unmapPartition(m_sessionId))
+        {
+            RIALTO_SERVER_LOG_ERROR("Unable to unmap shm partition");
+        }
+
+        m_shmBuffer.reset();
+        m_mainThread->unregisterClient(m_mainThreadClientId);
+    };
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
 }
 
 std::vector<std::string> MediaPipelineServerInternal::getSupportedCaps(MediaSourceType type)
@@ -144,6 +176,17 @@ std::vector<std::string> MediaPipelineServerInternal::getSupportedCaps(MediaSour
 }
 
 bool MediaPipelineServerInternal::load(MediaType type, const std::string &mimeType, const std::string &url)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = loadInternal(type, mimeType, url); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::loadInternal(MediaType type, const std::string &mimeType, const std::string &url)
 {
     /* If gstreamer player already created, destroy the old one first */
     if (m_gstPlayer)
@@ -164,6 +207,17 @@ bool MediaPipelineServerInternal::load(MediaType type, const std::string &mimeTy
 }
 
 bool MediaPipelineServerInternal::attachSource(MediaSource &source)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = attachSourceInternal(source); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::attachSourceInternal(MediaSource &source)
 {
     source.setId(-1);
 
@@ -192,67 +246,141 @@ bool MediaPipelineServerInternal::removeSource(int32_t id)
 }
 
 bool MediaPipelineServerInternal::play()
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = playInternal(); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::playInternal()
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to play - Gstreamer player has not been loaded");
         return false;
     }
+
     m_gstPlayer->play();
     return true;
 }
 
 bool MediaPipelineServerInternal::pause()
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = pauseInternal(); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::pauseInternal()
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to pause - Gstreamer player has not been loaded");
         return false;
     }
+
     m_gstPlayer->pause();
     return true;
 }
 
 bool MediaPipelineServerInternal::stop()
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = stopInternal(); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::stopInternal()
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to stop - Gstreamer player has not been loaded");
         return false;
     }
+
     m_gstPlayer->stop();
     return true;
 }
 
 bool MediaPipelineServerInternal::setPlaybackRate(double rate)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = setPlaybackRateInternal(rate); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::setPlaybackRateInternal(double rate)
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to set playback rate - Gstreamer player has not been loaded");
         return false;
     }
+
     if (0.0 == rate)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to set playback rate to 0.0 - pause method should be used instead.");
         return false;
     }
+
     m_gstPlayer->setPlaybackRate(rate);
     return true;
 }
 
 bool MediaPipelineServerInternal::setPosition(int64_t position)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = setPositionInternal(position); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::setPositionInternal(int64_t position)
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to set position - Gstreamer player has not been loaded");
         return false;
     }
+
     m_gstPlayer->setPosition(position);
     return true;
 }
 
 bool MediaPipelineServerInternal::getPosition(int64_t &position)
 {
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = getPositionInternal(position); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::getPositionInternal(int64_t &position)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to get position - Gstreamer player has not been loaded");
@@ -262,17 +390,40 @@ bool MediaPipelineServerInternal::getPosition(int64_t &position)
 }
 
 bool MediaPipelineServerInternal::setVideoWindow(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = setVideoWindowInternal(x, y, width, height); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::setVideoWindowInternal(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
 {
     if (!m_gstPlayer)
     {
         RIALTO_SERVER_LOG_ERROR("Failed to set video window - Gstreamer player has not been loaded");
         return false;
     }
+
     m_gstPlayer->setVideoGeometry(x, y, width, height);
     return true;
 }
 
 bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t needDataRequestId)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = haveDataInternal(status, needDataRequestId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::haveDataInternal(MediaSourceStatus status, uint32_t needDataRequestId)
 {
     if (!m_gstPlayer)
     {
@@ -292,7 +443,7 @@ bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t ne
         RIALTO_SERVER_LOG_WARN("Data request for needDataRequestId: %u received with wrong status: %s",
                                needDataRequestId, toString(status));
         m_activeRequests->erase(needDataRequestId);
-        return notifyNeedMediaData(mediaSourceType); // Resend NeedMediaData
+        return notifyNeedMediaDataInternal(mediaSourceType); // Resend NeedMediaData
     }
 
     try
@@ -317,6 +468,18 @@ bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t ne
 }
 
 bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t numFrames, uint32_t needDataRequestId)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = haveDataInternal(status, numFrames, needDataRequestId); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::haveDataInternal(MediaSourceStatus status, uint32_t numFrames,
+                                                   uint32_t needDataRequestId)
 {
     if (!m_gstPlayer)
     {
@@ -333,7 +496,7 @@ bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t nu
     if (status != MediaSourceStatus::OK && status != MediaSourceStatus::EOS)
     {
         RIALTO_SERVER_LOG_WARN("Data request for needDataRequestId: %u received with wrong status", needDataRequestId);
-        return notifyNeedMediaData(mediaSourceType); // Resend NeedMediaData
+        return notifyNeedMediaDataInternal(mediaSourceType); // Resend NeedMediaData
     }
     uint8_t *data = m_shmBuffer->getBufferForSession(m_sessionId);
     if (!data)
@@ -377,6 +540,18 @@ bool MediaPipelineServerInternal::haveData(MediaSourceStatus status, uint32_t nu
 
 AddSegmentStatus MediaPipelineServerInternal::addSegment(uint32_t needDataRequestId,
                                                          const std::unique_ptr<MediaSegment> &mediaSegment)
+{
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    AddSegmentStatus status;
+    auto task = [&]() { status = addSegmentInternal(needDataRequestId, mediaSegment); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return status;
+}
+
+AddSegmentStatus MediaPipelineServerInternal::addSegmentInternal(uint32_t needDataRequestId,
+                                                                 const std::unique_ptr<MediaSegment> &mediaSegment)
 {
     AddSegmentStatus status = m_activeRequests->addSegment(needDataRequestId, mediaSegment);
     if (status != AddSegmentStatus::OK)
@@ -396,15 +571,29 @@ void MediaPipelineServerInternal::notifyPlaybackState(PlaybackState state)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
-    if (m_mediaPipelineClient)
-    {
-        m_mediaPipelineClient->notifyPlaybackState(state);
-    }
+    auto task = [&, state]() {
+        if (m_mediaPipelineClient)
+        {
+            m_mediaPipelineClient->notifyPlaybackState(state);
+        }
+    };
+
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 bool MediaPipelineServerInternal::notifyNeedMediaData(MediaSourceType mediaSourceType)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    bool result;
+    auto task = [&]() { result = notifyNeedMediaDataInternal(mediaSourceType); };
+
+    m_mainThread->enqueueTaskAndWait(m_mainThreadClientId, task);
+    return result;
+}
+
+bool MediaPipelineServerInternal::notifyNeedMediaDataInternal(MediaSourceType mediaSourceType)
+{
     m_shmBuffer->clearBuffer(m_sessionId, mediaSourceType);
     NeedMediaData event{m_mediaPipelineClient, *m_activeRequests, *m_shmBuffer, m_sessionId, mediaSourceType};
     if (!event.send())
@@ -419,36 +608,52 @@ void MediaPipelineServerInternal::notifyPosition(std::int64_t position)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
-    if (m_mediaPipelineClient)
-    {
-        m_mediaPipelineClient->notifyPosition(position);
-    }
+    auto task = [&, position]() {
+        if (m_mediaPipelineClient)
+        {
+            m_mediaPipelineClient->notifyPosition(position);
+        }
+    };
+
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaPipelineServerInternal::notifyNetworkState(NetworkState state)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
-    if (m_mediaPipelineClient)
-    {
-        m_mediaPipelineClient->notifyNetworkState(state);
-    }
+    auto task = [&, state]() {
+        if (m_mediaPipelineClient)
+        {
+            m_mediaPipelineClient->notifyNetworkState(state);
+        }
+    };
+
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaPipelineServerInternal::clearActiveRequestsCache()
 {
-    m_activeRequests->clear();
+    RIALTO_SERVER_LOG_DEBUG("entry:");
+
+    auto task = [&]() { m_activeRequests->clear(); };
+
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 void MediaPipelineServerInternal::notifyQos(MediaSourceType mediaSourceType, const QosInfo &qosInfo)
 {
     RIALTO_SERVER_LOG_DEBUG("entry:");
 
-    if (m_mediaPipelineClient)
-    {
-        auto sourceId = static_cast<std::uint64_t>(mediaSourceType);
-        m_mediaPipelineClient->notifyQos(sourceId, qosInfo);
-    }
+    auto task = [&, mediaSourceType, qosInfo]() {
+        if (m_mediaPipelineClient)
+        {
+            auto sourceId = static_cast<std::uint64_t>(mediaSourceType);
+            m_mediaPipelineClient->notifyQos(sourceId, qosInfo);
+        }
+    };
+
+    m_mainThread->enqueueTask(m_mainThreadClientId, task);
 }
 
 }; // namespace firebolt::rialto::server
diff --git a/media/server/service/CMakeLists.txt b/media/server/service/CMakeLists.txt
index f95f1f1..6547156 100644
--- a/media/server/service/CMakeLists.txt
+++ b/media/server/service/CMakeLists.txt
@@ -22,7 +22,6 @@ set( CMAKE_INCLUDE_CURRENT_DIR ON )
 add_library (
         RialtoServerService STATIC
 
-        source/MainThread.cpp
         source/PlaybackService.cpp
         source/CdmService.cpp
         source/SessionServerManager.cpp
diff --git a/media/server/service/source/CdmService.cpp b/media/server/service/source/CdmService.cpp
index 0559542..f069ccd 100644
--- a/media/server/service/source/CdmService.cpp
+++ b/media/server/service/source/CdmService.cpp
@@ -21,7 +21,6 @@
 #include "RialtoServerLogging.h"
 #include <algorithm>
 #include <exception>
-#include <future>
 #include <memory>
 #include <string>
 #include <utility>
@@ -29,10 +28,9 @@
 
 namespace firebolt::rialto::server::service
 {
-CdmService::CdmService(IMainThread &mainThread, std::shared_ptr<IMediaKeysServerInternalFactory> &&mediaKeysFactory,
+CdmService::CdmService(std::shared_ptr<IMediaKeysServerInternalFactory> &&mediaKeysFactory,
                        std::shared_ptr<IMediaKeysCapabilitiesFactory> &&mediaKeysCapabilitiesFactory)
-    : m_mainThread{mainThread}, m_mediaKeysFactory{mediaKeysFactory},
-      m_mediaKeysCapabilitiesFactory{mediaKeysCapabilitiesFactory}, m_isActive{false}
+    : m_mediaKeysFactory{mediaKeysFactory}, m_mediaKeysCapabilitiesFactory{mediaKeysCapabilitiesFactory}, m_isActive{false}
 {
     RIALTO_SERVER_LOG_DEBUG("CdmService is constructed");
 }
@@ -44,218 +42,186 @@ CdmService::~CdmService()
 
 bool CdmService::switchToActive()
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [this, &promise]() {
-        RIALTO_SERVER_LOG_INFO("Switching SessionServer to Active state.");
-
-        m_mediaKeysCapabilities = m_mediaKeysCapabilitiesFactory->getMediaKeysCapabilities();
-        if (!m_mediaKeysCapabilities)
-        {
-            RIALTO_SERVER_LOG_ERROR("SessionServer failed to switch to active");
-            return promise.set_value(false);
-        }
-        m_isActive = true;
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("Switching SessionServer to Active state.");
+    m_isActive = true;
+    return true;
 }
 
 void CdmService::switchToInactive()
 {
-    auto task = [this]() {
-        RIALTO_SERVER_LOG_INFO("Switching SessionServer to Inactive state. Cleaning resources...");
-        m_isActive = false;
-        m_mediaKeysCapabilities.reset();
+    RIALTO_SERVER_LOG_INFO("Switching SessionServer to Inactive state. Cleaning resources...");
+    m_isActive = false;
+
+    {
+        std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
         m_mediaKeys.clear();
-    };
-    m_mainThread.enqueueTask(task);
+    }
 }
 
 bool CdmService::createMediaKeys(int mediaKeysHandle, std::string keySystem)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to create new media keys handle: %d", mediaKeysHandle);
-        if (!m_isActive)
-        {
-            RIALTO_SERVER_LOG_ERROR("Skip to create media keys handle: %d - Session Server in Inactive state",
-                                    mediaKeysHandle);
-            return promise.set_value(false);
-        }
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to create new media keys handle: %d", mediaKeysHandle);
+    if (!m_isActive)
+    {
+        RIALTO_SERVER_LOG_ERROR("Skip to create media keys handle: %d - Session Server in Inactive state",
+                                mediaKeysHandle);
+        return false;
+    }
+
+    {
+        std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
         if (m_mediaKeys.find(mediaKeysHandle) != m_mediaKeys.end())
         {
             RIALTO_SERVER_LOG_ERROR("Media keys handle: %d already exists", mediaKeysHandle);
-            return promise.set_value(false);
+            return false;
         }
         m_mediaKeys.emplace(std::make_pair(mediaKeysHandle, m_mediaKeysFactory->createMediaKeysServerInternal(keySystem)));
         if (!m_mediaKeys.at(mediaKeysHandle))
         {
             RIALTO_SERVER_LOG_ERROR("Could not create MediaKeys for media keys handle: %d", mediaKeysHandle);
             m_mediaKeys.erase(mediaKeysHandle);
-            return promise.set_value(false);
+            return false;
         }
-        RIALTO_SERVER_LOG_INFO("New media keys handle: %d created", mediaKeysHandle);
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    }
+
+    RIALTO_SERVER_LOG_INFO("New media keys handle: %d created", mediaKeysHandle);
+    return true;
 }
 
 bool CdmService::destroyMediaKeys(int mediaKeysHandle)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to destroy media keys handle: %d", mediaKeysHandle);
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to destroy media keys handle: %d", mediaKeysHandle);
+
+    {
+        std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
         auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
         if (mediaKeysIter == m_mediaKeys.end())
         {
             RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(false);
+            return false;
         }
         m_mediaKeys.erase(mediaKeysIter);
-        RIALTO_SERVER_LOG_INFO("Media keys handle: %d destroyed", mediaKeysHandle);
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    }
+
+    RIALTO_SERVER_LOG_INFO("Media keys handle: %d destroyed", mediaKeysHandle);
+    return true;
 }
 
 MediaKeyErrorStatus CdmService::createKeySession(int mediaKeysHandle, KeySessionType sessionType,
                                                  const std::shared_ptr<IMediaKeysClient> &client, bool isLDL,
                                                  int32_t &keySessionId)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to create key session: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to create key session: %d", mediaKeysHandle);
 
-        MediaKeyErrorStatus status = mediaKeysIter->second->createKeySession(sessionType, client, isLDL, keySessionId);
-        if (MediaKeyErrorStatus::OK == status)
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+
+    MediaKeyErrorStatus status = mediaKeysIter->second->createKeySession(sessionType, client, isLDL, keySessionId);
+    if (MediaKeyErrorStatus::OK == status)
+    {
+        if (m_mediaKeysClients.find(keySessionId) != m_mediaKeysClients.end())
         {
-            if (m_mediaKeysClients.find(keySessionId) != m_mediaKeysClients.end())
-            {
-                RIALTO_SERVER_LOG_ERROR("Media keys client for key session: %d already exists", keySessionId);
-                static_cast<void>(removeKeySession(mediaKeysHandle, keySessionId));
-                return promise.set_value(MediaKeyErrorStatus::FAIL);
-            }
-            m_mediaKeysClients.emplace(std::make_pair(keySessionId, client));
+            RIALTO_SERVER_LOG_ERROR("Media keys client for key session: %d already exists", keySessionId);
+            static_cast<void>(removeKeySessionInternal(mediaKeysHandle, keySessionId));
+            return MediaKeyErrorStatus::FAIL;
         }
-        return promise.set_value(status);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+        m_mediaKeysClients.emplace(std::make_pair(keySessionId, client));
+    }
+
+    return status;
 }
 
 MediaKeyErrorStatus CdmService::generateRequest(int mediaKeysHandle, int32_t keySessionId, InitDataType initDataType,
                                                 const std::vector<uint8_t> &initData)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to generate request: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
-        return promise.set_value(mediaKeysIter->second->generateRequest(keySessionId, initDataType, initData));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to generate request: %d", mediaKeysHandle);
+
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+    return mediaKeysIter->second->generateRequest(keySessionId, initDataType, initData);
 }
 
 MediaKeyErrorStatus CdmService::loadSession(int mediaKeysHandle, int32_t keySessionId)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to load session: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
-        return promise.set_value(mediaKeysIter->second->loadSession(keySessionId));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to load session: %d", mediaKeysHandle);
+
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+    return mediaKeysIter->second->loadSession(keySessionId);
 }
 
 MediaKeyErrorStatus CdmService::updateSession(int mediaKeysHandle, int32_t keySessionId,
                                               const std::vector<uint8_t> &responseData)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to update session: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
-        return promise.set_value(mediaKeysIter->second->updateSession(keySessionId, responseData));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to update session: %d", mediaKeysHandle);
+
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+    return mediaKeysIter->second->updateSession(keySessionId, responseData);
 }
 
 MediaKeyErrorStatus CdmService::closeKeySession(int mediaKeysHandle, int32_t keySessionId)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to close key session: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
-        return promise.set_value(mediaKeysIter->second->closeKeySession(keySessionId));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to close key session: %d", mediaKeysHandle);
+
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+    return mediaKeysIter->second->closeKeySession(keySessionId);
 }
 
 MediaKeyErrorStatus CdmService::removeKeySession(int mediaKeysHandle, int32_t keySessionId)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to remove key session: %d", mediaKeysHandle);
-        auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to remove key session: %d", mediaKeysHandle);
 
-        MediaKeyErrorStatus status = mediaKeysIter->second->removeKeySession(keySessionId);
-        if (MediaKeyErrorStatus::OK == status)
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    return removeKeySessionInternal(mediaKeysHandle, keySessionId);
+}
+
+MediaKeyErrorStatus CdmService::removeKeySessionInternal(int mediaKeysHandle, int32_t keySessionId)
+{
+    auto mediaKeysIter = m_mediaKeys.find(mediaKeysHandle);
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle: %d does not exists", mediaKeysHandle);
+        return MediaKeyErrorStatus::FAIL;
+    }
+
+    MediaKeyErrorStatus status = mediaKeysIter->second->removeKeySession(keySessionId);
+    if (MediaKeyErrorStatus::OK == status)
+    {
+        auto mediaKeysClientsIter = m_mediaKeysClients.find(keySessionId);
+        if (mediaKeysClientsIter != m_mediaKeysClients.end())
         {
-            auto mediaKeysClientsIter = m_mediaKeysClients.find(keySessionId);
-            if (mediaKeysClientsIter != m_mediaKeysClients.end())
-            {
-                m_mediaKeysClients.erase(mediaKeysClientsIter);
-            }
+            m_mediaKeysClients.erase(mediaKeysClientsIter);
         }
-        return promise.set_value(status);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    }
+
+    return status;
 }
 
 MediaKeyErrorStatus CdmService::getCdmKeySessionId(int mediaKeysHandle, int32_t keySessionId, std::string &cdmKeySessionId)
@@ -280,71 +246,76 @@ MediaKeyErrorStatus CdmService::getCdmKeySessionId(int mediaKeysHandle, int32_t
 
 std::vector<std::string> CdmService::getSupportedKeySystems()
 {
-    std::promise<std::vector<std::string>> promise;
-    std::future<std::vector<std::string>> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to getSupportedKeySystems");
-        if (!m_mediaKeysCapabilities)
-        {
-            return promise.set_value({});
-        }
-        return promise.set_value(m_mediaKeysCapabilities->getSupportedKeySystems());
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to getSupportedKeySystems");
+
+    if (!m_isActive)
+    {
+        RIALTO_SERVER_LOG_ERROR("Skip to get supported key systems: Session Server in Inactive state");
+        return {};
+    }
+
+    auto mediaKeysCapabilities = m_mediaKeysCapabilitiesFactory->getMediaKeysCapabilities();
+    if (!mediaKeysCapabilities)
+    {
+        RIALTO_SERVER_LOG_ERROR("Failed to create the mediaKeysCapabilities object");
+        return {};
+    }
+    return mediaKeysCapabilities->getSupportedKeySystems();
 }
 
 bool CdmService::supportsKeySystem(const std::string &keySystem)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to supportsKeySystem");
-        if (!m_mediaKeysCapabilities)
-        {
-            return promise.set_value(false);
-        }
-        return promise.set_value(m_mediaKeysCapabilities->supportsKeySystem(keySystem));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to supportsKeySystem");
+
+    if (!m_isActive)
+    {
+        RIALTO_SERVER_LOG_ERROR("Skip to get supported key systems: Session Server in Inactive state");
+        return false;
+    }
+
+    auto mediaKeysCapabilities = m_mediaKeysCapabilitiesFactory->getMediaKeysCapabilities();
+    if (!mediaKeysCapabilities)
+    {
+        RIALTO_SERVER_LOG_ERROR("Failed to create the mediaKeysCapabilities object");
+        return false;
+    }
+    return mediaKeysCapabilities->supportsKeySystem(keySystem);
 }
 
 bool CdmService::getSupportedKeySystemVersion(const std::string &keySystem, std::string &version)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to getSupportedKeySystemVersion");
-        if (!m_mediaKeysCapabilities)
-        {
-            return promise.set_value(false);
-        }
-        return promise.set_value(m_mediaKeysCapabilities->getSupportedKeySystemVersion(keySystem, version));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to getSupportedKeySystemVersion");
+
+    if (!m_isActive)
+    {
+        RIALTO_SERVER_LOG_ERROR("Skip to get supported key systems: Session Server in Inactive state");
+        return false;
+    }
+
+    auto mediaKeysCapabilities = m_mediaKeysCapabilitiesFactory->getMediaKeysCapabilities();
+    if (!mediaKeysCapabilities)
+    {
+        RIALTO_SERVER_LOG_ERROR("Failed to create the mediaKeysCapabilities object");
+        return false;
+    }
+    return mediaKeysCapabilities->getSupportedKeySystemVersion(keySystem, version);
 }
 
 MediaKeyErrorStatus CdmService::decrypt(int32_t keySessionId, GstBuffer *encrypted, GstBuffer *subSample,
                                         const uint32_t subSampleCount, GstBuffer *IV, GstBuffer *keyId,
                                         uint32_t initWithLast15)
 {
-    std::promise<MediaKeyErrorStatus> promise;
-    std::future<MediaKeyErrorStatus> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("CdmService requested to decrypt, key session id: %d", keySessionId);
-        auto mediaKeysIter = std::find_if(m_mediaKeys.begin(), m_mediaKeys.end(),
-                                          [&](const auto &iter) { return iter.second->hasSession(keySessionId); });
-        if (mediaKeysIter == m_mediaKeys.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Media keys handle for mksId: %d does not exists", keySessionId);
-            return promise.set_value(MediaKeyErrorStatus::FAIL);
-        }
-        return promise.set_value(mediaKeysIter->second->decrypt(keySessionId, encrypted, subSample, subSampleCount, IV,
-                                                                keyId, initWithLast15));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("CdmService requested to decrypt, key session id: %d", keySessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaKeysMutex};
+    auto mediaKeysIter = std::find_if(m_mediaKeys.begin(), m_mediaKeys.end(),
+                                      [&](const auto &iter) { return iter.second->hasSession(keySessionId); });
+    if (mediaKeysIter == m_mediaKeys.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Media keys handle for mksId: %d does not exists", keySessionId);
+        return MediaKeyErrorStatus::FAIL;
+    }
+    return mediaKeysIter->second->decrypt(keySessionId, encrypted, subSample, subSampleCount, IV,
+                                          keyId, initWithLast15);
 }
 } // namespace firebolt::rialto::server::service
diff --git a/media/server/service/source/CdmService.h b/media/server/service/source/CdmService.h
index ba7a7d9..d657363 100644
--- a/media/server/service/source/CdmService.h
+++ b/media/server/service/source/CdmService.h
@@ -22,7 +22,7 @@
 
 #include "ICdmService.h"
 #include "IDecryptionService.h"
-#include "IMainThread.h"
+#include <atomic>
 #include <condition_variable>
 #include <functional>
 #include <map>
@@ -35,7 +35,7 @@ namespace firebolt::rialto::server::service
 class CdmService : public ICdmService, public IDecryptionService
 {
 public:
-    CdmService(IMainThread &mainThread, std::shared_ptr<IMediaKeysServerInternalFactory> &&mediaKeysFactory,
+    CdmService(std::shared_ptr<IMediaKeysServerInternalFactory> &&mediaKeysFactory,
                std::shared_ptr<IMediaKeysCapabilitiesFactory> &&mediaKeysCapabilitiesFactory);
     virtual ~CdmService();
 
@@ -65,13 +65,14 @@ public:
                                 uint32_t initWithLast15) override;
 
 private:
-    IMainThread &m_mainThread;
     std::shared_ptr<IMediaKeysServerInternalFactory> m_mediaKeysFactory;
     std::shared_ptr<IMediaKeysCapabilitiesFactory> m_mediaKeysCapabilitiesFactory;
-    bool m_isActive;
+    std::atomic<bool> m_isActive;
     std::map<int, std::unique_ptr<IMediaKeysServerInternal>> m_mediaKeys;
     std::map<int, std::shared_ptr<IMediaKeysClient>> m_mediaKeysClients;
-    std::shared_ptr<IMediaKeysCapabilities> m_mediaKeysCapabilities;
+    std::mutex m_mediaKeysMutex;
+
+    MediaKeyErrorStatus removeKeySessionInternal(int mediaKeysHandle, int32_t keySessionId);
 };
 } // namespace firebolt::rialto::server::service
 
diff --git a/media/server/service/source/IMainThread.h b/media/server/service/source/IMainThread.h
deleted file mode 100644
index 0517dc5..0000000
--- a/media/server/service/source/IMainThread.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * If not stated otherwise in this file or this component's LICENSE file the
- * following copyright and licenses apply:
- *
- * Copyright 2022 Sky UK
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef FIREBOLT_RIALTO_SERVER_SERVICE_I_MAIN_THREAD_H_
-#define FIREBOLT_RIALTO_SERVER_SERVICE_I_MAIN_THREAD_H_
-
-#include "IMainThread.h"
-#include <functional>
-#include <utility>
-
-namespace firebolt::rialto::server::service
-{
-/**
- * @brief The definition of the IMainThread interface.
- */
-class IMainThread
-{
-public:
-    using Task = std::function<void()>;
-
-    IMainThread() = default;
-    virtual ~IMainThread() = default;
-
-    IMainThread(const IMainThread &) = delete;
-    IMainThread(IMainThread &&) = delete;
-    IMainThread &operator=(const IMainThread &) = delete;
-    IMainThread &operator=(IMainThread &&) = delete;
-
-    virtual void enqueueTask(Task task) = 0;
-};
-} // namespace firebolt::rialto::server::service
-
-#endif // FIREBOLT_RIALTO_SERVER_SERVICE_I_MAIN_THREAD_H_
diff --git a/media/server/service/source/MainThread.cpp b/media/server/service/source/MainThread.cpp
deleted file mode 100644
index e2e6eb2..0000000
--- a/media/server/service/source/MainThread.cpp
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * If not stated otherwise in this file or this component's LICENSE file the
- * following copyright and licenses apply:
- *
- * Copyright 2022 Sky UK
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "MainThread.h"
-#include "RialtoServerLogging.h"
-#include <string>
-#include <utility>
-#include <vector>
-
-namespace firebolt::rialto::server::service
-{
-MainThread::MainThread() : m_isMainThreadRunning{true}
-{
-    RIALTO_SERVER_LOG_DEBUG("MainThread is constructed");
-    m_thread = std::thread(std::bind(&MainThread::mainThreadLoop, this));
-}
-
-MainThread::~MainThread()
-{
-    RIALTO_SERVER_LOG_DEBUG("MainThread is destructed");
-    auto shutdownTask = [this]() { m_isMainThreadRunning = false; };
-    enqueueTask(shutdownTask);
-    m_thread.join();
-}
-
-void MainThread::mainThreadLoop()
-{
-    while (m_isMainThreadRunning)
-    {
-        Task task = waitForTask();
-        task();
-    }
-}
-
-MainThread::Task MainThread::waitForTask()
-{
-    std::unique_lock<std::mutex> lock(m_taskMutex);
-    if (m_taskQueue.empty())
-    {
-        m_taskCv.wait(lock, [this] { return !m_taskQueue.empty(); });
-    }
-    Task task = m_taskQueue.front();
-    m_taskQueue.pop();
-    return task;
-}
-
-void MainThread::enqueueTask(MainThread::Task task)
-{
-    {
-        std::unique_lock<std::mutex> lock(m_taskMutex);
-        m_taskQueue.push(task);
-    }
-    m_taskCv.notify_one();
-}
-} // namespace firebolt::rialto::server::service
diff --git a/media/server/service/source/PlaybackService.cpp b/media/server/service/source/PlaybackService.cpp
index 8b68613..38acc79 100644
--- a/media/server/service/source/PlaybackService.cpp
+++ b/media/server/service/source/PlaybackService.cpp
@@ -28,12 +28,10 @@
 
 namespace firebolt::rialto::server::service
 {
-PlaybackService::PlaybackService(IMainThread &mainThread,
-                                 std::shared_ptr<IMediaPipelineServerInternalFactory> &&mediaPipelineFactory,
+PlaybackService::PlaybackService(std::shared_ptr<IMediaPipelineServerInternalFactory> &&mediaPipelineFactory,
                                  std::unique_ptr<ISharedMemoryBufferFactory> &&shmBufferFactory,
                                  IDecryptionService &decryptionService)
-    : m_mainThread{mainThread}, m_mediaPipelineFactory{mediaPipelineFactory}, m_shmBufferFactory{std::move(
-                                                                                  shmBufferFactory)},
+    : m_mediaPipelineFactory{mediaPipelineFactory}, m_shmBufferFactory{std::move(shmBufferFactory)},
       m_decryptionService{decryptionService}, m_isActive{false}, m_maxPlaybacks{0}
 {
     RIALTO_SERVER_LOG_DEBUG("PlaybackService is constructed");
@@ -46,36 +44,30 @@ PlaybackService::~PlaybackService()
 
 bool PlaybackService::switchToActive()
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [this, &promise]() {
-        try
-        {
-            RIALTO_SERVER_LOG_INFO("Switching SessionServer to Active state.");
-            m_shmBuffer = m_shmBufferFactory->createSharedMemoryBuffer(m_maxPlaybacks);
-            m_isActive = true;
-            return promise.set_value(true);
-        }
-        catch (const std::exception &e)
-        {
-            RIALTO_SERVER_LOG_ERROR("SessionServer failed to switch to active: %s", e.what());
-            m_isActive = false;
-            return promise.set_value(false);
-        }
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    try
+    {
+        RIALTO_SERVER_LOG_INFO("Switching SessionServer to Active state.");
+        m_shmBuffer = m_shmBufferFactory->createSharedMemoryBuffer(m_maxPlaybacks);
+        m_isActive = true;
+        return true;
+    }
+    catch (const std::exception &e)
+    {
+        RIALTO_SERVER_LOG_ERROR("SessionServer failed to switch to active: %s", e.what());
+        m_isActive = false;
+        return false;
+    }
 }
 
 void PlaybackService::switchToInactive()
 {
-    auto task = [this]() {
-        RIALTO_SERVER_LOG_INFO("Switching SessionServer to Inactive state. Cleaning resources...");
-        m_isActive = false;
+    RIALTO_SERVER_LOG_INFO("Switching SessionServer to Inactive state. Cleaning resources...");
+    m_isActive = false;
+    {
+        std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
         m_mediaPipelines.clear();
-        m_shmBuffer.reset();
-    };
-    m_mainThread.enqueueTask(task);
+    }
+    m_shmBuffer.reset();
 }
 
 void PlaybackService::setMaxPlaybacks(int maxPlaybacks)
@@ -87,211 +79,178 @@ void PlaybackService::setMaxPlaybacks(int maxPlaybacks)
 bool PlaybackService::createSession(int sessionId, const std::shared_ptr<IMediaPipelineClient> &mediaPipelineClient,
                                     std::uint32_t maxWidth, std::uint32_t maxHeight)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("PlaybackService requested to create new session with id: %d", sessionId);
-        if (!m_isActive)
-        {
-            RIALTO_SERVER_LOG_ERROR("Skip to create session with id: %d - Session Server in Inactive state", sessionId);
-            return promise.set_value(false);
-        }
+    RIALTO_SERVER_LOG_DEBUG("PlaybackService requested to create new session with id: %d", sessionId);
+    if (!m_isActive)
+    {
+        RIALTO_SERVER_LOG_ERROR("Skip to create session with id: %d - Session Server in Inactive state", sessionId);
+        return false;
+    }
+
+    {
+        std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
         if (m_mediaPipelines.size() == static_cast<size_t>(m_maxPlaybacks))
         {
             RIALTO_SERVER_LOG_ERROR("Unable to create a session with id: %d. Max session number reached.", sessionId);
-            return promise.set_value(false);
+            return false;
         }
         if (m_mediaPipelines.find(sessionId) != m_mediaPipelines.end())
         {
             RIALTO_SERVER_LOG_ERROR("Session with id: %d already exists", sessionId);
-            return promise.set_value(false);
+            return false;
         }
+        auto shmBuffer = m_shmBuffer;
         m_mediaPipelines.emplace(
             std::make_pair(sessionId,
                            m_mediaPipelineFactory->createMediaPipelineServerInternal(mediaPipelineClient,
                                                                                      VideoRequirements{maxWidth, maxHeight},
-                                                                                     sessionId, m_shmBuffer,
+                                                                                     sessionId, shmBuffer,
                                                                                      m_decryptionService)));
         if (!m_mediaPipelines.at(sessionId))
         {
             RIALTO_SERVER_LOG_ERROR("Could not create MediaPipeline for session with id: %d", sessionId);
             m_mediaPipelines.erase(sessionId);
-            return promise.set_value(false);
+            return false;
         }
-        RIALTO_SERVER_LOG_INFO("New session with id: %d created", sessionId);
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    }
+
+    RIALTO_SERVER_LOG_INFO("New session with id: %d created", sessionId);
+    return true;
 }
 
 bool PlaybackService::destroySession(int sessionId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("PlaybackService requested to destroy session with id: %d", sessionId);
+    RIALTO_SERVER_LOG_DEBUG("PlaybackService requested to destroy session with id: %d", sessionId);
+    {
+        std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
         auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
         if (mediaPipelineIter == m_mediaPipelines.end())
         {
             RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
+            return false;
         }
         m_mediaPipelines.erase(mediaPipelineIter);
-        RIALTO_SERVER_LOG_INFO("Session with id: %d destroyed", sessionId);
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    }
+    RIALTO_SERVER_LOG_INFO("Session with id: %d destroyed", sessionId);
+    return true;
 }
 
 bool PlaybackService::load(int sessionId, MediaType type, const std::string &mimeType, const std::string &url)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to load session with id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->load(type, mimeType, url));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to load session with id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->load(type, mimeType, url);
 }
 
 bool PlaybackService::attachSource(int sessionId, IMediaPipeline::MediaSource &source)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to attach source, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->attachSource(source));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to attach source, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->attachSource(source);
 }
 
 bool PlaybackService::removeSource(int sessionId, std::int32_t sourceId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to remove source, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->removeSource(sourceId));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to remove source, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->removeSource(sourceId);
 }
 
 bool PlaybackService::play(int sessionId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to play, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->play());
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to play, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->play();
 }
 
 bool PlaybackService::pause(int sessionId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to pause, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->pause());
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to pause, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->pause();
 }
 
 bool PlaybackService::stop(int sessionId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to stop, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->stop());
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to stop, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->stop();
 }
 
 bool PlaybackService::setPlaybackRate(int sessionId, double rate)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to set playback rate, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->setPlaybackRate(rate));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to set playback rate, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->setPlaybackRate(rate);
 }
 
 bool PlaybackService::setPosition(int sessionId, std::int64_t position)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to set position, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->setPosition(position));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to set position, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->setPosition(position);
 }
 
 bool PlaybackService::getPosition(int sessionId, std::int64_t &position)
 {
     RIALTO_SERVER_LOG_INFO("PlaybackService requested to get position, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
     auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
     if (mediaPipelineIter == m_mediaPipelines.end())
     {
@@ -304,55 +263,43 @@ bool PlaybackService::getPosition(int sessionId, std::int64_t &position)
 bool PlaybackService::setVideoWindow(int sessionId, std::uint32_t x, std::uint32_t y, std::uint32_t width,
                                      std::uint32_t height)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_INFO("PlaybackService requested to set video window, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->setVideoWindow(x, y, width, height));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_INFO("PlaybackService requested to set video window, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->setVideoWindow(x, y, width, height);
 }
 
 bool PlaybackService::haveData(int sessionId, MediaSourceStatus status, std::uint32_t numFrames,
                                std::uint32_t needDataRequestId)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        RIALTO_SERVER_LOG_DEBUG("New data available, session id: %d", sessionId);
-        auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
-        if (mediaPipelineIter == m_mediaPipelines.end())
-        {
-            RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
-            return promise.set_value(false);
-        }
-        return promise.set_value(mediaPipelineIter->second->haveData(status, numFrames, needDataRequestId));
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    RIALTO_SERVER_LOG_DEBUG("New data available, session id: %d", sessionId);
+
+    std::lock_guard<std::mutex> lock{m_mediaPipelineMutex};
+    auto mediaPipelineIter = m_mediaPipelines.find(sessionId);
+    if (mediaPipelineIter == m_mediaPipelines.end())
+    {
+        RIALTO_SERVER_LOG_ERROR("Session with id: %d does not exists", sessionId);
+        return false;
+    }
+    return mediaPipelineIter->second->haveData(status, numFrames, needDataRequestId);
 }
 
 bool PlaybackService::getSharedMemory(int32_t &fd, uint32_t &size)
 {
-    std::promise<bool> promise;
-    std::future<bool> future = promise.get_future();
-    auto task = [&]() {
-        if (!m_shmBuffer)
-        {
-            return promise.set_value(false);
-        }
-        fd = m_shmBuffer->getFd();
-        size = m_shmBuffer->getSize();
-        return promise.set_value(true);
-    };
-    m_mainThread.enqueueTask(task);
-    return future.get();
+    auto shmBuffer = m_shmBuffer;
+
+    if (!shmBuffer)
+    {
+        return false;
+    }
+    fd = shmBuffer->getFd();
+    size = shmBuffer->getSize();
+    return true;
 }
 } // namespace firebolt::rialto::server::service
diff --git a/media/server/service/source/PlaybackService.h b/media/server/service/source/PlaybackService.h
index 1a6b25a..345fcd0 100644
--- a/media/server/service/source/PlaybackService.h
+++ b/media/server/service/source/PlaybackService.h
@@ -21,10 +21,10 @@
 #define FIREBOLT_RIALTO_SERVER_SERVICE_PLAYBACK_SERVICE_H_
 
 #include "IDecryptionService.h"
-#include "IMainThread.h"
 #include "IMediaPipelineServerInternal.h"
 #include "IPlaybackService.h"
 #include "ISharedMemoryBuffer.h"
+#include <atomic>
 #include <condition_variable>
 #include <functional>
 #include <map>
@@ -39,7 +39,7 @@ namespace firebolt::rialto::server::service
 class PlaybackService : public IPlaybackService
 {
 public:
-    PlaybackService(IMainThread &mainThread, std::shared_ptr<IMediaPipelineServerInternalFactory> &&mediaPipelineFactory,
+    PlaybackService(std::shared_ptr<IMediaPipelineServerInternalFactory> &&mediaPipelineFactory,
                     std::unique_ptr<ISharedMemoryBufferFactory> &&shmBufferFactory,
                     IDecryptionService &decryptionService);
     ~PlaybackService() override;
@@ -71,14 +71,14 @@ public:
     bool getSharedMemory(int32_t &fd, uint32_t &size) override;
 
 private:
-    IMainThread &m_mainThread;
     std::shared_ptr<IMediaPipelineServerInternalFactory> m_mediaPipelineFactory;
     std::unique_ptr<ISharedMemoryBufferFactory> m_shmBufferFactory;
     IDecryptionService &m_decryptionService;
-    bool m_isActive;
-    int m_maxPlaybacks;
+    std::atomic<bool> m_isActive;
+    std::atomic<int> m_maxPlaybacks;
     std::map<int, std::unique_ptr<IMediaPipelineServerInternal>> m_mediaPipelines;
     std::shared_ptr<ISharedMemoryBuffer> m_shmBuffer;
+    std::mutex m_mediaPipelineMutex;
 };
 } // namespace firebolt::rialto::server::service
 
diff --git a/media/server/service/source/main.cpp b/media/server/service/source/main.cpp
index d708512..c207530 100644
--- a/media/server/service/source/main.cpp
+++ b/media/server/service/source/main.cpp
@@ -24,7 +24,6 @@
 #include "IMediaPipelineServerInternal.h"
 #include "ISharedMemoryBuffer.h"
 #include "IpcFactory.h"
-#include "MainThread.h"
 #include "PlaybackService.h"
 #include "SessionServerManager.h"
 #include <cstdlib>
@@ -37,12 +36,11 @@ int main(int argc, char *argv[])
     firebolt::rialto::server::IGstPlayer::initalise(argc, argv);
 
     firebolt::rialto::server::ipc::IpcFactory ipcFactory;
-    firebolt::rialto::server::service::MainThread mainThread;
     firebolt::rialto::server::service::CdmService
-        cdmService{mainThread, firebolt::rialto::server::IMediaKeysServerInternalFactory::createFactory(),
+        cdmService{firebolt::rialto::server::IMediaKeysServerInternalFactory::createFactory(),
                    firebolt::rialto::IMediaKeysCapabilitiesFactory::createFactory()};
     firebolt::rialto::server::service::PlaybackService
-        playbackService{mainThread, firebolt::rialto::server::IMediaPipelineServerInternalFactory::createFactory(),
+        playbackService{firebolt::rialto::server::IMediaPipelineServerInternalFactory::createFactory(),
                         firebolt::rialto::server::ISharedMemoryBufferFactory::createFactory(), cdmService};
     firebolt::rialto::server::service::SessionServerManager serviceManager{ipcFactory, playbackService, cdmService};
     if (!serviceManager.initialize(argc, argv))
diff --git a/tests/media/client/ipc/mediaKeysIpc/CallbackTest.cpp b/tests/media/client/ipc/mediaKeysIpc/CallbackTest.cpp
index 68b9628..d9b3798 100644
--- a/tests/media/client/ipc/mediaKeysIpc/CallbackTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/CallbackTest.cpp
@@ -87,7 +87,7 @@ protected:
         auto licenseRequestEvent = std::make_shared<firebolt::rialto::LicenseRequestEvent>();
         licenseRequestEvent->set_media_keys_handle(m_mediaKeysHandle);
         licenseRequestEvent->set_url(m_url);
-        licenseRequestEvent->set_key_session_id(m_keySessionId);
+        licenseRequestEvent->set_key_session_id(m_kKeySessionId);
 
         for (auto it = m_licenseRequestMessage.begin(); it != m_licenseRequestMessage.end(); it++)
         {
@@ -101,7 +101,7 @@ protected:
     {
         auto keyStatusesChangedEvent = std::make_shared<firebolt::rialto::KeyStatusesChangedEvent>();
         keyStatusesChangedEvent->set_media_keys_handle(m_mediaKeysHandle);
-        keyStatusesChangedEvent->set_key_session_id(m_keySessionId);
+        keyStatusesChangedEvent->set_key_session_id(m_kKeySessionId);
 
         for (auto it = m_keyStatuses.begin(); it != m_keyStatuses.end(); it++)
         {
@@ -126,7 +126,7 @@ TEST_F(RialtoClientMediaKeysIpcCallbackTest, NotifyLicenseRequest)
     createKeySession();
 
     EXPECT_CALL(*m_eventThreadMock, addImpl(_)).WillOnce(Invoke([](std::function<void()> &&func) { func(); }));
-    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_keySessionId, m_licenseRequestMessage, m_url));
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_kKeySessionId, m_licenseRequestMessage, m_url));
 
     m_licenseRequestCb(createLicenseRequestEvent());
 }
@@ -162,7 +162,7 @@ TEST_F(RialtoClientMediaKeysIpcCallbackTest, NotifyLicenseRenewal)
     createKeySession();
 
     EXPECT_CALL(*m_eventThreadMock, addImpl(_)).WillOnce(Invoke([](std::function<void()> &&func) { func(); }));
-    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRenewal(m_keySessionId, m_licenseRenewalMessage));
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRenewal(m_kKeySessionId, m_licenseRenewalMessage));
 
     m_licenseRenewalCb(createLicenseRenewalEvent());
 }
@@ -199,7 +199,7 @@ TEST_F(RialtoClientMediaKeysIpcCallbackTest, NotifyKeyStatusesChanged)
     addPairsToKeyStatusVector(3);
 
     EXPECT_CALL(*m_eventThreadMock, addImpl(_)).WillOnce(Invoke([](std::function<void()> &&func) { func(); }));
-    EXPECT_CALL(*m_mediaKeysClientMock, onKeyStatusesChanged(m_keySessionId, m_keyStatuses));
+    EXPECT_CALL(*m_mediaKeysClientMock, onKeyStatusesChanged(m_kKeySessionId, m_keyStatuses));
 
     m_KeyStatusesChangeCb(createKeyStatusesChangedEvent());
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/CloseKeySessionTest.cpp b/tests/media/client/ipc/mediaKeysIpc/CloseKeySessionTest.cpp
index 0b283c8..0044b68 100644
--- a/tests/media/client/ipc/mediaKeysIpc/CloseKeySessionTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/CloseKeySessionTest.cpp
@@ -62,12 +62,12 @@ TEST_F(RialtoClientMediaKeysIpcCloseKeySessionTest, Success)
     expectIpcApiCallSuccess();
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("closeKeySession"), m_controllerMock.get(),
-                                           closeKeySessionRequestMatcher(m_mediaKeysHandle, m_keySessionId), _,
+                                           closeKeySessionRequestMatcher(m_mediaKeysHandle, m_kKeySessionId), _,
                                            m_blockingClosureMock.get()))
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcCloseKeySessionTest::setCloseKeySessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 
     // Check client object has been removed, no call to the client mock
     EXPECT_CALL(*m_eventThreadMock, addImpl(_)).WillOnce(Invoke([](std::function<void()> &&func) { func(); }));
@@ -82,7 +82,7 @@ TEST_F(RialtoClientMediaKeysIpcCloseKeySessionTest, ChannelDisconnected)
     expectIpcApiCallDisconnected();
     expectUnsubscribeEvents();
 
-    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 
     // Reattach channel on destroySession
     EXPECT_CALL(*m_ipcClientMock, getChannel()).WillOnce(Return(m_channelMock)).RetiresOnSaturation();
@@ -102,7 +102,7 @@ TEST_F(RialtoClientMediaKeysIpcCloseKeySessionTest, ReconnectChannel)
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcCloseKeySessionTest::setCloseKeySessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -114,7 +114,7 @@ TEST_F(RialtoClientMediaKeysIpcCloseKeySessionTest, Failure)
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("closeKeySession"), _, _, _, _));
 
-    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 }
 
 /**
@@ -128,5 +128,5 @@ TEST_F(RialtoClientMediaKeysIpcCloseKeySessionTest, ErrorReturn)
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcCloseKeySessionTest::setCloseKeySessionResponseFailed)));
 
-    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_keySessionId), m_errorStatus);
+    EXPECT_EQ(m_mediaKeysIpc->closeKeySession(m_kKeySessionId), m_errorStatus);
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/CreateKeySessionTest.cpp b/tests/media/client/ipc/mediaKeysIpc/CreateKeySessionTest.cpp
index f71c4d2..de58d91 100644
--- a/tests/media/client/ipc/mediaKeysIpc/CreateKeySessionTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/CreateKeySessionTest.cpp
@@ -57,7 +57,7 @@ public:
     {
         firebolt::rialto::CreateKeySessionResponse *createKeySessionResponse =
             dynamic_cast<firebolt::rialto::CreateKeySessionResponse *>(response);
-        createKeySessionResponse->set_key_session_id(m_keySessionId);
+        createKeySessionResponse->set_key_session_id(m_kKeySessionId);
         createKeySessionResponse->set_error_status(MediaKeysIpcTestBase::convertMediaKeyErrorStatus(m_errorStatus));
     }
 };
@@ -78,7 +78,7 @@ TEST_F(RialtoClientMediaKeysIpcCreateKeySessionTest, Success)
 
     EXPECT_EQ(m_mediaKeysIpc->createKeySession(m_keySessionType, m_mediaKeysClientMock, m_isLdl, returnKeySessionid),
               MediaKeyErrorStatus::OK);
-    EXPECT_EQ(returnKeySessionid, m_keySessionId);
+    EXPECT_EQ(returnKeySessionid, m_kKeySessionId);
 
     // Check client object has been stored
     EXPECT_CALL(*m_eventThreadMock, addImpl(_)).WillOnce(Invoke([](std::function<void()> &&func) { func(); }));
diff --git a/tests/media/client/ipc/mediaKeysIpc/GenerateRequestTest.cpp b/tests/media/client/ipc/mediaKeysIpc/GenerateRequestTest.cpp
index 41d174c..1ce08a3 100644
--- a/tests/media/client/ipc/mediaKeysIpc/GenerateRequestTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/GenerateRequestTest.cpp
@@ -81,12 +81,12 @@ TEST_F(RialtoClientMediaKeysIpcGenerateRequestTest, Success)
 
     EXPECT_CALL(*m_channelMock,
                 CallMethod(methodMatcher("generateRequest"), m_controllerMock.get(),
-                           generateRequestRequestMatcher(m_mediaKeysHandle, m_keySessionId, m_initDataType, m_initData),
+                           generateRequestRequestMatcher(m_mediaKeysHandle, m_kKeySessionId, m_initDataType, m_initData),
                            _, m_blockingClosureMock.get()))
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcGenerateRequestTest::setGenerateRequestResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_keySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_kKeySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -97,7 +97,7 @@ TEST_F(RialtoClientMediaKeysIpcGenerateRequestTest, ChannelDisconnected)
     expectIpcApiCallDisconnected();
     expectUnsubscribeEvents();
 
-    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_keySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_kKeySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::FAIL);
 
     // Reattach channel on destroySession
     EXPECT_CALL(*m_ipcClientMock, getChannel()).WillOnce(Return(m_channelMock)).RetiresOnSaturation();
@@ -117,7 +117,7 @@ TEST_F(RialtoClientMediaKeysIpcGenerateRequestTest, ReconnectChannel)
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcGenerateRequestTest::setGenerateRequestResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_keySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_kKeySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -129,7 +129,7 @@ TEST_F(RialtoClientMediaKeysIpcGenerateRequestTest, Failure)
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("generateRequest"), _, _, _, _));
 
-    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_keySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_kKeySessionId, m_initDataType, m_initData), MediaKeyErrorStatus::FAIL);
 }
 
 /**
@@ -143,5 +143,5 @@ TEST_F(RialtoClientMediaKeysIpcGenerateRequestTest, ErrorReturn)
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcGenerateRequestTest::setGenerateRequestResponseFailed)));
 
-    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_keySessionId, m_initDataType, m_initData), m_errorStatus);
+    EXPECT_EQ(m_mediaKeysIpc->generateRequest(m_kKeySessionId, m_initDataType, m_initData), m_errorStatus);
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/LoadSessionTest.cpp b/tests/media/client/ipc/mediaKeysIpc/LoadSessionTest.cpp
index 1ae03be..6da380b 100644
--- a/tests/media/client/ipc/mediaKeysIpc/LoadSessionTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/LoadSessionTest.cpp
@@ -57,11 +57,11 @@ TEST_F(RialtoClientMediaKeysIpcLoadSessionTest, Success)
     expectIpcApiCallSuccess();
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("loadSession"), m_controllerMock.get(),
-                                           loadSessionRequestMatcher(m_mediaKeysHandle, m_keySessionId), _,
+                                           loadSessionRequestMatcher(m_mediaKeysHandle, m_kKeySessionId), _,
                                            m_blockingClosureMock.get()))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcLoadSessionTest::setLoadSessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -72,7 +72,7 @@ TEST_F(RialtoClientMediaKeysIpcLoadSessionTest, ChannelDisconnected)
     expectIpcApiCallDisconnected();
     expectUnsubscribeEvents();
 
-    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 
     // Reattach channel on destroySession
     EXPECT_CALL(*m_ipcClientMock, getChannel()).WillOnce(Return(m_channelMock)).RetiresOnSaturation();
@@ -91,7 +91,7 @@ TEST_F(RialtoClientMediaKeysIpcLoadSessionTest, ReconnectChannel)
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("loadSession"), _, _, _, _))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcLoadSessionTest::setLoadSessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -103,7 +103,7 @@ TEST_F(RialtoClientMediaKeysIpcLoadSessionTest, Failure)
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("loadSession"), _, _, _, _));
 
-    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 }
 
 /**
@@ -116,5 +116,5 @@ TEST_F(RialtoClientMediaKeysIpcLoadSessionTest, ErrorReturn)
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("loadSession"), _, _, _, _))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcLoadSessionTest::setLoadSessionResponseFailed)));
 
-    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_keySessionId), m_errorStatus);
+    EXPECT_EQ(m_mediaKeysIpc->loadSession(m_kKeySessionId), m_errorStatus);
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/RemoveKeySessionTest.cpp b/tests/media/client/ipc/mediaKeysIpc/RemoveKeySessionTest.cpp
index 9aac022..df7d4cb 100644
--- a/tests/media/client/ipc/mediaKeysIpc/RemoveKeySessionTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/RemoveKeySessionTest.cpp
@@ -58,12 +58,12 @@ TEST_F(RialtoClientMediaKeysIpcRemoveKeySessionTest, Success)
     expectIpcApiCallSuccess();
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("removeKeySession"), m_controllerMock.get(),
-                                           removeKeySessionRequestMatcher(m_mediaKeysHandle, m_keySessionId), _,
+                                           removeKeySessionRequestMatcher(m_mediaKeysHandle, m_kKeySessionId), _,
                                            m_blockingClosureMock.get()))
         .WillOnce(WithArgs<3>(
             Invoke(this, &RialtoClientMediaKeysIpcRemoveKeySessionTest::setRemoveKeySessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -74,7 +74,7 @@ TEST_F(RialtoClientMediaKeysIpcRemoveKeySessionTest, ChannelDisconnected)
     expectIpcApiCallDisconnected();
     expectUnsubscribeEvents();
 
-    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 
     // Reattach channel on destroySession
     EXPECT_CALL(*m_ipcClientMock, getChannel()).WillOnce(Return(m_channelMock)).RetiresOnSaturation();
@@ -94,7 +94,7 @@ TEST_F(RialtoClientMediaKeysIpcRemoveKeySessionTest, ReconnectChannel)
         .WillOnce(WithArgs<3>(
             Invoke(this, &RialtoClientMediaKeysIpcRemoveKeySessionTest::setRemoveKeySessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_keySessionId), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_kKeySessionId), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -106,7 +106,7 @@ TEST_F(RialtoClientMediaKeysIpcRemoveKeySessionTest, Failure)
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("removeKeySession"), _, _, _, _));
 
-    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_keySessionId), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_kKeySessionId), MediaKeyErrorStatus::FAIL);
 }
 
 /**
@@ -120,5 +120,5 @@ TEST_F(RialtoClientMediaKeysIpcRemoveKeySessionTest, ErrorReturn)
         .WillOnce(
             WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcRemoveKeySessionTest::setRemoveKeySessionResponseFailed)));
 
-    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_keySessionId), m_errorStatus);
+    EXPECT_EQ(m_mediaKeysIpc->removeKeySession(m_kKeySessionId), m_errorStatus);
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/UpdateSessionTest.cpp b/tests/media/client/ipc/mediaKeysIpc/UpdateSessionTest.cpp
index 19bb2d0..cfde012 100644
--- a/tests/media/client/ipc/mediaKeysIpc/UpdateSessionTest.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/UpdateSessionTest.cpp
@@ -60,11 +60,11 @@ TEST_F(RialtoClientMediaKeysIpcUpdateSessionTest, Success)
     expectIpcApiCallSuccess();
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("updateSession"), m_controllerMock.get(),
-                                           updateSessionRequestMatcher(m_mediaKeysHandle, m_keySessionId, m_requestData),
+                                           updateSessionRequestMatcher(m_mediaKeysHandle, m_kKeySessionId, m_requestData),
                                            _, m_blockingClosureMock.get()))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcUpdateSessionTest::setUpdateSessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_keySessionId, m_requestData), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_kKeySessionId, m_requestData), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -75,7 +75,7 @@ TEST_F(RialtoClientMediaKeysIpcUpdateSessionTest, ChannelDisconnected)
     expectIpcApiCallDisconnected();
     expectUnsubscribeEvents();
 
-    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_keySessionId, m_requestData), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_kKeySessionId, m_requestData), MediaKeyErrorStatus::FAIL);
 
     // Reattach channel on destroySession
     EXPECT_CALL(*m_ipcClientMock, getChannel()).WillOnce(Return(m_channelMock)).RetiresOnSaturation();
@@ -94,7 +94,7 @@ TEST_F(RialtoClientMediaKeysIpcUpdateSessionTest, ReconnectChannel)
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("updateSession"), _, _, _, _))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcUpdateSessionTest::setUpdateSessionResponseSuccess)));
 
-    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_keySessionId, m_requestData), MediaKeyErrorStatus::OK);
+    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_kKeySessionId, m_requestData), MediaKeyErrorStatus::OK);
 }
 
 /**
@@ -106,7 +106,7 @@ TEST_F(RialtoClientMediaKeysIpcUpdateSessionTest, Failure)
 
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("updateSession"), _, _, _, _));
 
-    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_keySessionId, m_requestData), MediaKeyErrorStatus::FAIL);
+    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_kKeySessionId, m_requestData), MediaKeyErrorStatus::FAIL);
 }
 
 /**
@@ -119,5 +119,5 @@ TEST_F(RialtoClientMediaKeysIpcUpdateSessionTest, ErrorReturn)
     EXPECT_CALL(*m_channelMock, CallMethod(methodMatcher("updateSession"), _, _, _, _))
         .WillOnce(WithArgs<3>(Invoke(this, &RialtoClientMediaKeysIpcUpdateSessionTest::setUpdateSessionResponseFailed)));
 
-    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_keySessionId, m_requestData), m_errorStatus);
+    EXPECT_EQ(m_mediaKeysIpc->updateSession(m_kKeySessionId, m_requestData), m_errorStatus);
 }
diff --git a/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.cpp b/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.cpp
index 9c7b3c2..0cc0776 100644
--- a/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.cpp
+++ b/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.cpp
@@ -106,7 +106,7 @@ std::shared_ptr<firebolt::rialto::LicenseRenewalEvent> MediaKeysIpcTestBase::cre
 {
     auto licenseRenewalEvent = std::make_shared<firebolt::rialto::LicenseRenewalEvent>();
     licenseRenewalEvent->set_media_keys_handle(m_mediaKeysHandle);
-    licenseRenewalEvent->set_key_session_id(m_keySessionId);
+    licenseRenewalEvent->set_key_session_id(m_kKeySessionId);
 
     for (auto it = m_licenseRenewalMessage.begin(); it != m_licenseRenewalMessage.end(); it++)
     {
@@ -127,7 +127,7 @@ void MediaKeysIpcTestBase::setCreateKeySessionResponseSuccess(google::protobuf::
 {
     firebolt::rialto::CreateKeySessionResponse *createKeySessionResponse =
         dynamic_cast<firebolt::rialto::CreateKeySessionResponse *>(response);
-    createKeySessionResponse->set_key_session_id(m_keySessionId);
+    createKeySessionResponse->set_key_session_id(m_kKeySessionId);
     createKeySessionResponse->set_error_status(MediaKeysIpcTestBase::convertMediaKeyErrorStatus(MediaKeyErrorStatus::OK));
 }
 
diff --git a/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.h b/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.h
index de8f49b..c3c4228 100644
--- a/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.h
+++ b/tests/media/client/ipc/mediaKeysIpc/base/MediaKeysIpcTestBase.h
@@ -84,7 +84,7 @@ protected:
     // Common variables
     int32_t m_mediaKeysHandle = 123;
     std::string m_keySystem = "keySystem";
-    int32_t m_keySessionId = 456;
+    int32_t m_kKeySessionId = 456;
     MediaKeyErrorStatus m_errorStatus = MediaKeyErrorStatus::BAD_SESSION_ID;
     std::vector<unsigned char> m_licenseRenewalMessage{'a', 'b', 'c'};
 
diff --git a/tests/media/client/main/mediaKeys/KeySessionTest.cpp b/tests/media/client/main/mediaKeys/KeySessionTest.cpp
index 26a0e7d..5bccea1 100644
--- a/tests/media/client/main/mediaKeys/KeySessionTest.cpp
+++ b/tests/media/client/main/mediaKeys/KeySessionTest.cpp
@@ -44,7 +44,7 @@ protected:
     std::unique_ptr<IMediaKeys> m_mediaKeys;
 
     std::string m_keySystem{"keySystem"};
-    int32_t m_keySessionId{123};
+    int32_t m_kKeySessionId{123};
     MediaKeyErrorStatus m_mediaKeyErrorStatus{MediaKeyErrorStatus::OK};
 
     RialtoClientMediaKeysKeySessionTest()
@@ -71,11 +71,11 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, CreateKeySession)
     int32_t returnKeySessionId;
 
     EXPECT_CALL(*m_mediaKeysIpcMock, createKeySession(sessionType, _, isLDL, _))
-        .WillOnce(DoAll(SetArgReferee<3>(m_keySessionId), Return(m_mediaKeyErrorStatus)));
+        .WillOnce(DoAll(SetArgReferee<3>(m_kKeySessionId), Return(m_mediaKeyErrorStatus)));
 
     EXPECT_EQ(m_mediaKeys->createKeySession(sessionType, mediaKeysClientMock, isLDL, returnKeySessionId),
               m_mediaKeyErrorStatus);
-    EXPECT_EQ(returnKeySessionId, m_keySessionId);
+    EXPECT_EQ(returnKeySessionId, m_kKeySessionId);
 }
 
 /**
@@ -86,10 +86,10 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, GenerateRequest)
     InitDataType initDataType = InitDataType::KEY_IDS;
     std::vector<uint8_t> initData{7, 8, 9};
 
-    EXPECT_CALL(*m_mediaKeysIpcMock, generateRequest(m_keySessionId, initDataType, initData))
+    EXPECT_CALL(*m_mediaKeysIpcMock, generateRequest(m_kKeySessionId, initDataType, initData))
         .WillOnce(Return(m_mediaKeyErrorStatus));
 
-    EXPECT_EQ(m_mediaKeys->generateRequest(m_keySessionId, initDataType, initData), m_mediaKeyErrorStatus);
+    EXPECT_EQ(m_mediaKeys->generateRequest(m_kKeySessionId, initDataType, initData), m_mediaKeyErrorStatus);
 }
 
 /**
@@ -97,9 +97,9 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, GenerateRequest)
  */
 TEST_F(RialtoClientMediaKeysKeySessionTest, LoadSession)
 {
-    EXPECT_CALL(*m_mediaKeysIpcMock, loadSession(m_keySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
+    EXPECT_CALL(*m_mediaKeysIpcMock, loadSession(m_kKeySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
 
-    EXPECT_EQ(m_mediaKeys->loadSession(m_keySessionId), m_mediaKeyErrorStatus);
+    EXPECT_EQ(m_mediaKeys->loadSession(m_kKeySessionId), m_mediaKeyErrorStatus);
 }
 
 /**
@@ -109,9 +109,9 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, UpdateSession)
 {
     std::vector<uint8_t> responseData{10, 11, 12};
 
-    EXPECT_CALL(*m_mediaKeysIpcMock, updateSession(m_keySessionId, responseData)).WillOnce(Return(m_mediaKeyErrorStatus));
+    EXPECT_CALL(*m_mediaKeysIpcMock, updateSession(m_kKeySessionId, responseData)).WillOnce(Return(m_mediaKeyErrorStatus));
 
-    EXPECT_EQ(m_mediaKeys->updateSession(m_keySessionId, responseData), m_mediaKeyErrorStatus);
+    EXPECT_EQ(m_mediaKeys->updateSession(m_kKeySessionId, responseData), m_mediaKeyErrorStatus);
 }
 
 /**
@@ -119,9 +119,9 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, UpdateSession)
  */
 TEST_F(RialtoClientMediaKeysKeySessionTest, CloseKeySession)
 {
-    EXPECT_CALL(*m_mediaKeysIpcMock, closeKeySession(m_keySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
+    EXPECT_CALL(*m_mediaKeysIpcMock, closeKeySession(m_kKeySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
 
-    EXPECT_EQ(m_mediaKeys->closeKeySession(m_keySessionId), m_mediaKeyErrorStatus);
+    EXPECT_EQ(m_mediaKeys->closeKeySession(m_kKeySessionId), m_mediaKeyErrorStatus);
 }
 
 /**
@@ -129,9 +129,9 @@ TEST_F(RialtoClientMediaKeysKeySessionTest, CloseKeySession)
  */
 TEST_F(RialtoClientMediaKeysKeySessionTest, RemoveKeySession)
 {
-    EXPECT_CALL(*m_mediaKeysIpcMock, removeKeySession(m_keySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
+    EXPECT_CALL(*m_mediaKeysIpcMock, removeKeySession(m_kKeySessionId)).WillOnce(Return(m_mediaKeyErrorStatus));
 
-    EXPECT_EQ(m_mediaKeys->removeKeySession(m_keySessionId), m_mediaKeyErrorStatus);
+    EXPECT_EQ(m_mediaKeys->removeKeySession(m_kKeySessionId), m_mediaKeyErrorStatus);
 }
 
 /**
diff --git a/tests/media/server/main/CMakeLists.txt b/tests/media/server/main/CMakeLists.txt
index f95f8f0..3d1b299 100644
--- a/tests/media/server/main/CMakeLists.txt
+++ b/tests/media/server/main/CMakeLists.txt
@@ -27,6 +27,7 @@ add_gtests (
         dataReader/DataReaderV1Tests.cpp
         dataReader/DataReaderV2Tests.cpp
 
+        mediaPipeline/base/MediaPipelineTestBase.cpp
         mediaPipeline/CreateTest.cpp
         mediaPipeline/LoadTest.cpp
         mediaPipeline/SourceTest.cpp
@@ -64,6 +65,8 @@ add_gtests (
 
         needMediaData/NeedMediaDataTestsFixture.cpp
         needMediaData/NeedMediaDataTests.cpp
+
+        mainThread/MainThreadTest.cpp
         )
 
 target_include_directories(
@@ -81,6 +84,7 @@ target_include_directories(
         # Test Bases
         mediaKeys/base
         mediaKeySession/base
+        mediaPipeline/base
         )
 
 target_link_libraries(
diff --git a/tests/media/server/main/mainThread/MainThreadTest.cpp b/tests/media/server/main/mainThread/MainThreadTest.cpp
new file mode 100644
index 0000000..a709973
--- /dev/null
+++ b/tests/media/server/main/mainThread/MainThreadTest.cpp
@@ -0,0 +1,136 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "MainThread.h"
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace firebolt::rialto::server;
+
+using ::testing::InSequence;
+
+class DummyMock
+{
+public:
+    MOCK_METHOD(void, mockMethod, (), ());
+};
+
+class MainThreadTests : public testing::Test
+{
+protected:
+    std::shared_ptr<IMainThread> m_mainThread;
+    const uint32_t m_mainThreadClientId{0};
+
+    void enqueueTaskAndWaitOnDummyMock(uint32_t clientId, const std::shared_ptr<DummyMock> &dummyMock)
+    {
+        auto task = [&, dummyMock]() { dummyMock->mockMethod(); };
+
+        m_mainThread->enqueueTaskAndWait(clientId, task);
+    }
+
+    void enqueueTaskOnDummyMock(uint32_t clientId, const std::shared_ptr<DummyMock> &dummyMock)
+    {
+        auto task = [&, dummyMock]() { dummyMock->mockMethod(); };
+
+        m_mainThread->enqueueTask(clientId, task);
+    }
+
+    void unregisterClient(uint32_t clientId)
+    {
+        auto task = [&, clientId]() { m_mainThread->unregisterClient(clientId); };
+
+        m_mainThread->enqueueTaskAndWait(clientId, task);
+    }
+};
+
+/**
+ * Test that a MainThread object can be created and destroyed successfully.
+ */
+TEST_F(MainThreadTests, CreateDestroy)
+{
+    m_mainThread = std::make_shared<MainThread>();
+}
+
+/**
+ * Test that a MainThread registeres itself on creation, and can enqueue tasks.
+ */
+TEST_F(MainThreadTests, RegisterItself)
+{
+    m_mainThread = std::make_shared<MainThread>();
+    std::shared_ptr<DummyMock> dummyMock = std::make_shared<DummyMock>();
+
+    EXPECT_CALL(*dummyMock, mockMethod());
+    enqueueTaskAndWaitOnDummyMock(m_mainThreadClientId, dummyMock);
+}
+
+/**
+ * Test that a MainThread can register, enqueue tasks & unregsister for multiple clients.
+ */
+TEST_F(MainThreadTests, MultipleClients)
+{
+    m_mainThread = std::make_shared<MainThread>();
+
+    uint32_t clientId1 = m_mainThread->registerClient();
+    uint32_t clientId2 = m_mainThread->registerClient();
+    uint32_t clientId3 = m_mainThread->registerClient();
+
+    // Test that the tasks are called in the right order
+    InSequence s;
+
+    std::shared_ptr<DummyMock> dummyMock1 = std::make_shared<DummyMock>();
+    std::shared_ptr<DummyMock> dummyMock2 = std::make_shared<DummyMock>();
+    std::shared_ptr<DummyMock> dummyMock3 = std::make_shared<DummyMock>();
+    EXPECT_CALL(*dummyMock2, mockMethod());
+    EXPECT_CALL(*dummyMock1, mockMethod());
+    EXPECT_CALL(*dummyMock3, mockMethod());
+
+    enqueueTaskOnDummyMock(clientId2, dummyMock2);
+    enqueueTaskOnDummyMock(clientId1, dummyMock1);
+    enqueueTaskAndWaitOnDummyMock(clientId3, dummyMock3);
+
+    unregisterClient(clientId3);
+    unregisterClient(clientId1);
+    unregisterClient(clientId2);
+}
+
+/**
+ * Test that a MainThread ignores tasks from unregistered clients.
+ */
+TEST_F(MainThreadTests, IgnoreUnregisteredClients)
+{
+    m_mainThread = std::make_shared<MainThread>();
+
+    uint32_t clientId1 = m_mainThread->registerClient();
+    uint32_t clientId2 = m_mainThread->registerClient();
+    uint32_t clientId3 = m_mainThread->registerClient();
+
+    unregisterClient(clientId3);
+    unregisterClient(clientId1);
+
+    std::shared_ptr<DummyMock> dummyMock1 = std::make_shared<DummyMock>();
+    std::shared_ptr<DummyMock> dummyMock2 = std::make_shared<DummyMock>();
+    std::shared_ptr<DummyMock> dummyMock3 = std::make_shared<DummyMock>();
+    EXPECT_CALL(*dummyMock2, mockMethod());
+
+    enqueueTaskOnDummyMock(clientId2, dummyMock2);
+    enqueueTaskOnDummyMock(clientId1, dummyMock1);
+    enqueueTaskAndWaitOnDummyMock(clientId3, dummyMock3);
+
+    unregisterClient(clientId2);
+}
diff --git a/tests/media/server/main/mediaKeySession/CallbacksTest.cpp b/tests/media/server/main/mediaKeySession/CallbacksTest.cpp
index cf81e68..948ce3c 100644
--- a/tests/media/server/main/mediaKeySession/CallbacksTest.cpp
+++ b/tests/media/server/main/mediaKeySession/CallbacksTest.cpp
@@ -19,15 +19,24 @@
 
 #include "MediaKeySessionTestBase.h"
 
+MATCHER_P2(keyIdMatcher, keyId, keyIdLength, "")
+{
+    if (0 == memcmp(arg, keyId, keyIdLength))
+        return true;
+
+    return false;
+}
+
 class RialtoServerMediaKeySessionCallbacksTest : public MediaKeySessionTestBase
 {
 protected:
-    const std::string m_url{"http://"};
-    const std::vector<unsigned char> m_licenseRequestMessage{'d', 'e', 'f'};
-    const std::vector<unsigned char> m_licenseRenewalMessage{'a', 'b', 'c'};
+    const std::string m_kUrl{"http://"};
+    const std::vector<unsigned char> m_kLicenseRequestMessage{'d', 'e', 'f'};
+    const std::vector<unsigned char> m_kLicenseRenewalMessage{'a', 'b', 'c'};
     KeyStatusVector m_keyStatusVec;
 
     RialtoServerMediaKeySessionCallbacksTest() { createKeySession(kWidevineKeySystem); }
+    ~RialtoServerMediaKeySessionCallbacksTest() { destroyKeySession(); }
 
     void createKeyStatusVec()
     {
@@ -42,9 +51,10 @@ protected:
  */
 TEST_F(RialtoServerMediaKeySessionCallbacksTest, ProcessChallengeNoGenerateRequest)
 {
-    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRenewal(m_keySessionId, m_licenseRenewalMessage));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRenewal(m_kKeySessionId, m_kLicenseRenewalMessage));
 
-    m_mediaKeySession->onProcessChallenge(m_url.c_str(), &m_licenseRenewalMessage[0], m_licenseRenewalMessage.size());
+    m_mediaKeySession->onProcessChallenge(m_kUrl.c_str(), &m_kLicenseRenewalMessage[0], m_kLicenseRenewalMessage.size());
 }
 
 /**
@@ -53,9 +63,10 @@ TEST_F(RialtoServerMediaKeySessionCallbacksTest, ProcessChallengeNoGenerateReque
 TEST_F(RialtoServerMediaKeySessionCallbacksTest, ProcessChallengeGenerateRequestNoneNetflix)
 {
     generateRequest();
-    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_keySessionId, m_licenseRequestMessage, m_url));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_kKeySessionId, m_kLicenseRequestMessage, m_kUrl));
 
-    m_mediaKeySession->onProcessChallenge(m_url.c_str(), &m_licenseRequestMessage[0], m_licenseRequestMessage.size());
+    m_mediaKeySession->onProcessChallenge(m_kUrl.c_str(), &m_kLicenseRequestMessage[0], m_kLicenseRequestMessage.size());
 
     // OcdmSession will be closed on destruction
     expectCloseKeySession(kWidevineKeySystem);
@@ -70,10 +81,13 @@ TEST_F(RialtoServerMediaKeySessionCallbacksTest, KeyStatusUpdate)
 
     for (auto it = m_keyStatusVec.begin(); it != m_keyStatusVec.end(); it++)
     {
-        EXPECT_CALL(*m_ocdmSessionMock, getStatus(&it->first[0], it->first.size())).WillOnce(Return(it->second));
+        mainThreadWillEnqueueTask();
+        EXPECT_CALL(*m_ocdmSessionMock, getStatus(keyIdMatcher(&it->first[0], it->first.size()), it->first.size()))
+            .WillOnce(Return(it->second));
         m_mediaKeySession->onKeyUpdated(&it->first[0], it->first.size());
     }
 
-    EXPECT_CALL(*m_mediaKeysClientMock, onKeyStatusesChanged(m_keySessionId, m_keyStatusVec));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaKeysClientMock, onKeyStatusesChanged(m_kKeySessionId, m_keyStatusVec));
     m_mediaKeySession->onAllKeysUpdated();
 }
diff --git a/tests/media/server/main/mediaKeySession/CloseKeySessionTest.cpp b/tests/media/server/main/mediaKeySession/CloseKeySessionTest.cpp
index ecb682c..514a698 100644
--- a/tests/media/server/main/mediaKeySession/CloseKeySessionTest.cpp
+++ b/tests/media/server/main/mediaKeySession/CloseKeySessionTest.cpp
@@ -21,6 +21,8 @@
 
 class RialtoServerMediaKeySessionCloseKeySessionTest : public MediaKeySessionTestBase
 {
+protected:
+    ~RialtoServerMediaKeySessionCloseKeySessionTest() { destroyKeySession(); }
 };
 
 /**
diff --git a/tests/media/server/main/mediaKeySession/CreateTest.cpp b/tests/media/server/main/mediaKeySession/CreateTest.cpp
index a26d20e..31cccb0 100644
--- a/tests/media/server/main/mediaKeySession/CreateTest.cpp
+++ b/tests/media/server/main/mediaKeySession/CreateTest.cpp
@@ -28,12 +28,32 @@ class RialtoServerCreateMediaKeySessionTest : public MediaKeySessionTestBase
  */
 TEST_F(RialtoServerCreateMediaKeySessionTest, Create)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemMock, createSession(_)).WillOnce(Return(ByMove(std::move(m_ocdmSession))));
 
-    EXPECT_NO_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(kNetflixKeySystem, m_keySessionId,
+    EXPECT_NO_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(kNetflixKeySystem, m_kKeySessionId,
                                                                           *m_ocdmSystemMock, m_keySessionType,
-                                                                          m_mediaKeysClientMock, m_isLDL));
+                                                                          m_mediaKeysClientMock, m_isLDL,
+                                                                          m_mainThreadFactoryMock));
     EXPECT_NE(m_mediaKeySession, nullptr);
+
+    destroyKeySession();
+}
+
+/**
+ * Test that a MediaKeySession object throws an exeption if failure occurs during construction.
+ * In this case, createMainThread fails, returning a nullptr.
+ */
+TEST_F(RialtoServerCreateMediaKeySessionTest, CreateMainThreadFailure)
+{
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(nullptr));
+
+    EXPECT_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(kNetflixKeySystem, m_kKeySessionId,
+                                                                       *m_ocdmSystemMock, m_keySessionType,
+                                                                       m_mediaKeysClientMock, m_isLDL,
+                                                                       m_mainThreadFactoryMock),
+                 std::runtime_error);
 }
 
 /**
@@ -42,10 +62,13 @@ TEST_F(RialtoServerCreateMediaKeySessionTest, Create)
  */
 TEST_F(RialtoServerCreateMediaKeySessionTest, CreateOcdmSessionFailure)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemMock, createSession(_)).WillOnce(Return(ByMove(std::move(nullptr))));
 
-    EXPECT_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(kNetflixKeySystem, m_keySessionId,
+    EXPECT_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(kNetflixKeySystem, m_kKeySessionId,
                                                                        *m_ocdmSystemMock, m_keySessionType,
-                                                                       m_mediaKeysClientMock, m_isLDL),
+                                                                       m_mediaKeysClientMock, m_isLDL,
+                                                                       m_mainThreadFactoryMock),
                  std::runtime_error);
 }
diff --git a/tests/media/server/main/mediaKeySession/DecryptTest.cpp b/tests/media/server/main/mediaKeySession/DecryptTest.cpp
index 3dac38f..23e38c9 100644
--- a/tests/media/server/main/mediaKeySession/DecryptTest.cpp
+++ b/tests/media/server/main/mediaKeySession/DecryptTest.cpp
@@ -24,10 +24,12 @@ class RialtoServerMediaKeySessionDecryptTest : public MediaKeySessionTestBase
 protected:
     GstBuffer m_encrypted{};
     GstBuffer m_subSample{};
-    const uint32_t m_subSampleCount{2};
+    const uint32_t m_kSubSampleCount{2};
     GstBuffer m_IV{};
     GstBuffer m_keyId{};
     uint32_t m_initWithLast15{1};
+
+    ~RialtoServerMediaKeySessionDecryptTest() { destroyKeySession(); }
 };
 
 /**
@@ -38,10 +40,10 @@ TEST_F(RialtoServerMediaKeySessionDecryptTest, Success)
     createKeySession(kWidevineKeySystem);
 
     EXPECT_CALL(*m_ocdmSessionMock,
-                decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId, m_initWithLast15))
+                decrypt(&m_encrypted, &m_subSample, m_kSubSampleCount, &m_IV, &m_keyId, m_initWithLast15))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV,
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->decrypt(&m_encrypted, &m_subSample, m_kSubSampleCount, &m_IV,
                                                                   &m_keyId, m_initWithLast15));
 }
 
@@ -53,9 +55,9 @@ TEST_F(RialtoServerMediaKeySessionDecryptTest, Fail)
     createKeySession(kWidevineKeySystem);
 
     EXPECT_CALL(*m_ocdmSessionMock,
-                decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId, m_initWithLast15))
+                decrypt(&m_encrypted, &m_subSample, m_kSubSampleCount, &m_IV, &m_keyId, m_initWithLast15))
         .WillOnce(Return(MediaKeyErrorStatus::FAIL));
 
-    EXPECT_EQ(MediaKeyErrorStatus::FAIL, m_mediaKeySession->decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV,
-                                                                    &m_keyId, m_initWithLast15));
+    EXPECT_EQ(MediaKeyErrorStatus::FAIL, m_mediaKeySession->decrypt(&m_encrypted, &m_subSample, m_kSubSampleCount,
+                                                                    &m_IV, &m_keyId, m_initWithLast15));
 }
diff --git a/tests/media/server/main/mediaKeySession/GenerateRequestTest.cpp b/tests/media/server/main/mediaKeySession/GenerateRequestTest.cpp
index 9b11fe9..d2a156e 100644
--- a/tests/media/server/main/mediaKeySession/GenerateRequestTest.cpp
+++ b/tests/media/server/main/mediaKeySession/GenerateRequestTest.cpp
@@ -19,42 +19,99 @@
 
 #include "MediaKeySessionTestBase.h"
 
+using ::testing::DoAll;
+using ::testing::SetArgPointee;
+
+MATCHER(nullptrMatcher, "")
+{
+    return arg == nullptr;
+}
+
+MATCHER(notNullptrMatcher, "")
+{
+    return arg != nullptr;
+}
+
+ACTION_P(memcpyChallenge, vec)
+{
+    memcpy(arg1, &vec[0], vec.size());
+}
+
 class RialtoServerMediaKeySessionGenerateRequestTest : public MediaKeySessionTestBase
 {
 protected:
-    InitDataType m_initDataType = InitDataType::CENC;
-    std::vector<uint8_t> m_initData{1, 2, 3};
+    const InitDataType m_kInitDataType = InitDataType::CENC;
+    const std::vector<uint8_t> m_kInitData{1, 2, 3};
+    const std::vector<unsigned char> m_kChallenge{'d', 'e', 'f'};
 
-    RialtoServerMediaKeySessionGenerateRequestTest() { createKeySession(kNetflixKeySystem); }
+    ~RialtoServerMediaKeySessionGenerateRequestTest() { destroyKeySession(); }
 };
 
 /**
- * Test that GenerateRequest can generate request successfully.
+ * Test that GenerateRequest can generate request successfully for an none netflix keysystem.
+ */
+TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, SuccessNoneNetflix)
+{
+    createKeySession(kWidevineKeySystem);
+
+    EXPECT_CALL(*m_ocdmSessionMock,
+                constructSession(m_keySessionType, m_kInitDataType, &m_kInitData[0], m_kInitData.size()))
+        .WillOnce(Return(MediaKeyErrorStatus::OK));
+
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_kInitDataType, m_kInitData));
+
+    // Close ocdm before destroying
+    expectCloseKeySession(kWidevineKeySystem);
+}
+
+/**
+ * Test that GenerateRequest can generate request successfully for a netflix keysystem.
  */
-TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, Success)
+TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, SuccessNetflix)
 {
-    EXPECT_CALL(*m_ocdmSessionMock, constructSession(m_keySessionType, m_initDataType, &m_initData[0], m_initData.size()))
+    createKeySession(kNetflixKeySystem);
+
+    EXPECT_CALL(*m_ocdmSessionMock,
+                constructSession(m_keySessionType, m_kInitDataType, &m_kInitData[0], m_kInitData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_ocdmSessionMock, getChallengeData(m_isLDL, nullptrMatcher(), _))
+        .WillOnce(DoAll(SetArgPointee<2>(m_kChallenge.size()), Return(MediaKeyErrorStatus::OK)));
+    EXPECT_CALL(*m_ocdmSessionMock, getChallengeData(m_isLDL, notNullptrMatcher(), _))
+        .WillOnce(DoAll(memcpyChallenge(m_kChallenge), Return(MediaKeyErrorStatus::OK)));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_kKeySessionId, m_kChallenge, _));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_initDataType, m_initData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_kInitDataType, m_kInitData));
 
     // Close ocdm before destroying
     expectCloseKeySession(kNetflixKeySystem);
 }
 
 /**
- * Test that GenerateRequest fails if session already constructed.
+ * Test that GenerateRequest manually fetches the challenge if the session has already been constructed.
  */
-TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, SessionAlreadyConstructedFailure)
+TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, SessionAlreadyConstructed)
 {
-    EXPECT_CALL(*m_ocdmSessionMock, constructSession(m_keySessionType, m_initDataType, &m_initData[0], m_initData.size()))
+    // Generate inital request
+    createKeySession(kWidevineKeySystem);
+    EXPECT_CALL(*m_ocdmSessionMock,
+                constructSession(m_keySessionType, m_kInitDataType, &m_kInitData[0], m_kInitData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_initDataType, m_initData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_kInitDataType, m_kInitData));
 
-    EXPECT_EQ(MediaKeyErrorStatus::FAIL, m_mediaKeySession->generateRequest(m_initDataType, m_initData));
+    // Generate request again should not call constructSession and trigger a onLicenseRequest
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_ocdmSessionMock, getChallengeData(m_isLDL, nullptrMatcher(), _))
+        .WillOnce(DoAll(SetArgPointee<2>(m_kChallenge.size()), Return(MediaKeyErrorStatus::OK)));
+    EXPECT_CALL(*m_ocdmSessionMock, getChallengeData(m_isLDL, notNullptrMatcher(), _))
+        .WillOnce(DoAll(SetArgPointee<2>(m_kChallenge.size()), Return(MediaKeyErrorStatus::OK)));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaKeysClientMock, onLicenseRequest(m_kKeySessionId, _, _));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_kInitDataType, m_kInitData));
 
     // OcdmSession will be closed on destruction
-    expectCloseKeySession(kNetflixKeySystem);
+    expectCloseKeySession(kWidevineKeySystem);
 }
 
 /**
@@ -62,7 +119,9 @@ TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, SessionAlreadyConstructed
  */
 TEST_F(RialtoServerMediaKeySessionGenerateRequestTest, OcdmSessionFailure)
 {
-    EXPECT_CALL(*m_ocdmSessionMock, constructSession(m_keySessionType, m_initDataType, &m_initData[0], m_initData.size()))
+    createKeySession(kWidevineKeySystem);
+    EXPECT_CALL(*m_ocdmSessionMock,
+                constructSession(m_keySessionType, m_kInitDataType, &m_kInitData[0], m_kInitData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::NOT_SUPPORTED));
-    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeySession->generateRequest(m_initDataType, m_initData));
+    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeySession->generateRequest(m_kInitDataType, m_kInitData));
 }
diff --git a/tests/media/server/main/mediaKeySession/LoadSessionTest.cpp b/tests/media/server/main/mediaKeySession/LoadSessionTest.cpp
index 2fb73fe..3af6d24 100644
--- a/tests/media/server/main/mediaKeySession/LoadSessionTest.cpp
+++ b/tests/media/server/main/mediaKeySession/LoadSessionTest.cpp
@@ -23,6 +23,7 @@ class RialtoServerMediaKeySessionLoadSessionTest : public MediaKeySessionTestBas
 {
 protected:
     RialtoServerMediaKeySessionLoadSessionTest() { createKeySession(kNetflixKeySystem); }
+    ~RialtoServerMediaKeySessionLoadSessionTest() { destroyKeySession(); }
 };
 
 /**
diff --git a/tests/media/server/main/mediaKeySession/RemoveKeySessionTest.cpp b/tests/media/server/main/mediaKeySession/RemoveKeySessionTest.cpp
index 2c3f94b..bf4310b 100644
--- a/tests/media/server/main/mediaKeySession/RemoveKeySessionTest.cpp
+++ b/tests/media/server/main/mediaKeySession/RemoveKeySessionTest.cpp
@@ -23,6 +23,7 @@ class RialtoServerMediaKeySessionRemoveKeySessionTest : public MediaKeySessionTe
 {
 protected:
     RialtoServerMediaKeySessionRemoveKeySessionTest() { createKeySession(kNetflixKeySystem); }
+    ~RialtoServerMediaKeySessionRemoveKeySessionTest() { destroyKeySession(); }
 };
 
 /**
diff --git a/tests/media/server/main/mediaKeySession/UpdateSessionTest.cpp b/tests/media/server/main/mediaKeySession/UpdateSessionTest.cpp
index 105be5d..2d2784f 100644
--- a/tests/media/server/main/mediaKeySession/UpdateSessionTest.cpp
+++ b/tests/media/server/main/mediaKeySession/UpdateSessionTest.cpp
@@ -22,7 +22,9 @@
 class RialtoServerMediaKeySessionUpdateSessionTest : public MediaKeySessionTestBase
 {
 protected:
-    std::vector<uint8_t> m_responseData{1, 2, 3};
+    const std::vector<uint8_t> m_kResponseData{1, 2, 3};
+
+    ~RialtoServerMediaKeySessionUpdateSessionTest() { destroyKeySession(); }
 };
 
 /**
@@ -32,10 +34,10 @@ TEST_F(RialtoServerMediaKeySessionUpdateSessionTest, SuccessNetflix)
 {
     createKeySession(kNetflixKeySystem);
 
-    EXPECT_CALL(*m_ocdmSessionMock, storeLicenseData(&m_responseData[0], m_responseData.size()))
+    EXPECT_CALL(*m_ocdmSessionMock, storeLicenseData(&m_kResponseData[0], m_kResponseData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->updateSession(m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->updateSession(m_kResponseData));
 }
 
 /**
@@ -45,10 +47,10 @@ TEST_F(RialtoServerMediaKeySessionUpdateSessionTest, SuccessNoneNetflix)
 {
     createKeySession(kWidevineKeySystem);
 
-    EXPECT_CALL(*m_ocdmSessionMock, update(&m_responseData[0], m_responseData.size()))
+    EXPECT_CALL(*m_ocdmSessionMock, update(&m_kResponseData[0], m_kResponseData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->updateSession(m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->updateSession(m_kResponseData));
 }
 
 /**
@@ -58,10 +60,10 @@ TEST_F(RialtoServerMediaKeySessionUpdateSessionTest, OcdmSessionStoreLicenseData
 {
     createKeySession(kNetflixKeySystem);
 
-    EXPECT_CALL(*m_ocdmSessionMock, storeLicenseData(&m_responseData[0], m_responseData.size()))
+    EXPECT_CALL(*m_ocdmSessionMock, storeLicenseData(&m_kResponseData[0], m_kResponseData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::INVALID_STATE));
 
-    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeySession->updateSession(m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeySession->updateSession(m_kResponseData));
 }
 
 /**
@@ -71,8 +73,8 @@ TEST_F(RialtoServerMediaKeySessionUpdateSessionTest, OcdmSessionUpdateFailure)
 {
     createKeySession(kWidevineKeySystem);
 
-    EXPECT_CALL(*m_ocdmSessionMock, update(&m_responseData[0], m_responseData.size()))
+    EXPECT_CALL(*m_ocdmSessionMock, update(&m_kResponseData[0], m_kResponseData.size()))
         .WillOnce(Return(MediaKeyErrorStatus::INVALID_STATE));
 
-    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeySession->updateSession(m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeySession->updateSession(m_kResponseData));
 }
diff --git a/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.cpp b/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.cpp
index e64b13a..ed87613 100644
--- a/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.cpp
+++ b/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.cpp
@@ -26,7 +26,9 @@
 MediaKeySessionTestBase::MediaKeySessionTestBase()
     : m_mediaKeysClientMock{std::make_shared<StrictMock<MediaKeysClientMock>>()},
       m_ocdmSystemMock{std::make_unique<StrictMock<OcdmSystemMock>>()},
-      m_ocdmSession{std::make_unique<StrictMock<OcdmSessionMock>>()}, m_ocdmSessionMock{m_ocdmSession.get()}
+      m_ocdmSession{std::make_unique<StrictMock<OcdmSessionMock>>()}, m_ocdmSessionMock{m_ocdmSession.get()},
+      m_mainThreadFactoryMock{std::make_shared<StrictMock<MainThreadFactoryMock>>()},
+      m_mainThreadMock{std::make_shared<StrictMock<MainThreadMock>>()}
 {
 }
 
@@ -34,14 +36,21 @@ MediaKeySessionTestBase::~MediaKeySessionTestBase() {}
 
 void MediaKeySessionTestBase::createKeySession(const std::string &keySystem)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemMock, createSession(_)).WillOnce(Return(ByMove(std::move(m_ocdmSession))));
 
-    EXPECT_NO_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(keySystem, m_keySessionId, *m_ocdmSystemMock,
+    EXPECT_NO_THROW(m_mediaKeySession = std::make_unique<MediaKeySession>(keySystem, m_kKeySessionId, *m_ocdmSystemMock,
                                                                           m_keySessionType, m_mediaKeysClientMock,
-                                                                          m_isLDL));
+                                                                          m_isLDL, m_mainThreadFactoryMock));
     EXPECT_NE(m_mediaKeySession, nullptr);
 }
 
+void MediaKeySessionTestBase::destroyKeySession()
+{
+    EXPECT_CALL(*m_mainThreadMock, unregisterClient(m_kMainThreadClientId));
+}
+
 void MediaKeySessionTestBase::expectCloseKeySession(const std::string &keySystem)
 {
     if (kNetflixKeySystem == keySystem)
@@ -67,3 +76,10 @@ void MediaKeySessionTestBase::generateRequest()
 
     EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeySession->generateRequest(m_initDataType, m_initData));
 }
+
+void MediaKeySessionTestBase::mainThreadWillEnqueueTask()
+{
+    EXPECT_CALL(*m_mainThreadMock, enqueueTask(m_kMainThreadClientId, _))
+        .WillOnce(Invoke([](uint32_t clientId, firebolt::rialto::server::IMainThread::Task task) { task(); }))
+        .RetiresOnSaturation();
+}
diff --git a/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.h b/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.h
index 18d65ee..b4e8e2c 100644
--- a/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.h
+++ b/tests/media/server/main/mediaKeySession/base/MediaKeySessionTestBase.h
@@ -20,6 +20,8 @@
 #ifndef MEDIA_KEY_SESSION_TEST_BASE_H_
 #define MEDIA_KEY_SESSION_TEST_BASE_H_
 
+#include "MainThreadFactoryMock.h"
+#include "MainThreadMock.h"
 #include "MediaKeySession.h"
 #include "MediaKeysClientMock.h"
 #include "MediaKeysCommon.h"
@@ -36,6 +38,7 @@ using namespace firebolt::rialto::server::mock;
 
 using ::testing::_;
 using ::testing::ByMove;
+using ::testing::Invoke;
 using ::testing::Return;
 using ::testing::StrictMock;
 
@@ -54,15 +57,20 @@ protected:
     std::unique_ptr<StrictMock<OcdmSystemMock>> m_ocdmSystemMock;
     std::unique_ptr<StrictMock<OcdmSessionMock>> m_ocdmSession;
     StrictMock<OcdmSessionMock> *m_ocdmSessionMock;
+    std::shared_ptr<StrictMock<MainThreadFactoryMock>> m_mainThreadFactoryMock;
+    std::shared_ptr<StrictMock<MainThreadMock>> m_mainThreadMock;
 
     // Common variables
-    const int32_t m_keySessionId = 123;
+    const int32_t m_kKeySessionId = 123;
+    const int32_t m_kMainThreadClientId = {5};
     KeySessionType m_keySessionType = KeySessionType::PERSISTENT_RELEASE_MESSAGE;
     bool m_isLDL = false;
 
     void createKeySession(const std::string &keySystem);
+    void destroyKeySession();
     void expectCloseKeySession(const std::string &keySystem);
     void generateRequest();
+    void mainThreadWillEnqueueTask();
 };
 
 #endif // MEDIA_KEY_SESSION_TEST_BASE_H_
diff --git a/tests/media/server/main/mediaKeys/CloseKeySessionTest.cpp b/tests/media/server/main/mediaKeys/CloseKeySessionTest.cpp
index 00ab2d1..d5e927c 100644
--- a/tests/media/server/main/mediaKeys/CloseKeySessionTest.cpp
+++ b/tests/media/server/main/mediaKeys/CloseKeySessionTest.cpp
@@ -27,6 +27,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysCloseKeySessionTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -34,9 +35,10 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysCloseKeySessionTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, closeKeySession()).WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->closeKeySession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->closeKeySession(m_kKeySessionId));
 }
 
 /**
@@ -44,7 +46,8 @@ TEST_F(RialtoServerMediaKeysCloseKeySessionTest, Success)
  */
 TEST_F(RialtoServerMediaKeysCloseKeySessionTest, SessionDoesNotExistFailure)
 {
-    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->closeKeySession(m_keySessionId + 1));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->closeKeySession(m_kKeySessionId + 1));
 }
 
 /**
@@ -52,7 +55,8 @@ TEST_F(RialtoServerMediaKeysCloseKeySessionTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysCloseKeySessionTest, SessionFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, closeKeySession()).WillOnce(Return(MediaKeyErrorStatus::INVALID_STATE));
 
-    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeys->closeKeySession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeys->closeKeySession(m_kKeySessionId));
 }
diff --git a/tests/media/server/main/mediaKeys/CreateKeySessionTest.cpp b/tests/media/server/main/mediaKeys/CreateKeySessionTest.cpp
index f168a04..349abf5 100644
--- a/tests/media/server/main/mediaKeys/CreateKeySessionTest.cpp
+++ b/tests/media/server/main/mediaKeys/CreateKeySessionTest.cpp
@@ -23,6 +23,7 @@ class RialtoServerMediaKeysCreateKeySessionTest : public MediaKeysTestBase
 {
 protected:
     RialtoServerMediaKeysCreateKeySessionTest() { createMediaKeys(kNetflixKeySystem); }
+    ~RialtoServerMediaKeysCreateKeySessionTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -31,6 +32,8 @@ protected:
 TEST_F(RialtoServerMediaKeysCreateKeySessionTest, Success)
 {
     int32_t returnKeySessionId = -1;
+
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionFactoryMock,
                 createMediaKeySession(kNetflixKeySystem, _, _, m_keySessionType, _, m_isLDL))
         .WillOnce(Return(ByMove(std::move(m_mediaKeySession))));
@@ -47,6 +50,8 @@ TEST_F(RialtoServerMediaKeysCreateKeySessionTest, Success)
 TEST_F(RialtoServerMediaKeysCreateKeySessionTest, OcdmSystemFailure)
 {
     int32_t returnKeySessionId = -1;
+
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionFactoryMock,
                 createMediaKeySession(kNetflixKeySystem, _, _, m_keySessionType, _, m_isLDL))
         .WillOnce(Return(ByMove(nullptr)));
diff --git a/tests/media/server/main/mediaKeys/CreateTest.cpp b/tests/media/server/main/mediaKeys/CreateTest.cpp
index 9b3c570..dbff26e 100644
--- a/tests/media/server/main/mediaKeys/CreateTest.cpp
+++ b/tests/media/server/main/mediaKeys/CreateTest.cpp
@@ -28,12 +28,34 @@ class RialtoServerCreateMediaKeysTest : public MediaKeysTestBase
  */
 TEST_F(RialtoServerCreateMediaKeysTest, Create)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemFactoryMock, createOcdmSystem(kWidevineKeySystem))
         .WillOnce(Return(ByMove(std::move(m_ocdmSystem))));
+    mainThreadWillEnqueueTaskAndWait();
 
-    EXPECT_NO_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(kWidevineKeySystem, m_ocdmSystemFactoryMock,
+    EXPECT_NO_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(kWidevineKeySystem, m_mainThreadFactoryMock,
+                                                                            m_ocdmSystemFactoryMock,
                                                                             m_mediaKeySessionFactoryMock));
     EXPECT_NE(m_mediaKeys, nullptr);
+
+    EXPECT_CALL(*m_mainThreadMock, unregisterClient(m_kMainThreadClientId));
+    // Objects are destroyed on the main thread
+    mainThreadWillEnqueueTaskAndWait();
+}
+
+/**
+ * Test that a MediaKeys object throws an exeption if failure occurs during construction.
+ * In this case, getMainThread fails, returning a nullptr.
+ */
+TEST_F(RialtoServerCreateMediaKeysTest, GetMainThreadFailure)
+{
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(nullptr));
+
+    EXPECT_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(kWidevineKeySystem, m_mainThreadFactoryMock,
+                                                                         m_ocdmSystemFactoryMock,
+                                                                         m_mediaKeySessionFactoryMock),
+                 std::runtime_error);
 }
 
 /**
@@ -42,9 +64,13 @@ TEST_F(RialtoServerCreateMediaKeysTest, Create)
  */
 TEST_F(RialtoServerCreateMediaKeysTest, CreateOcdmSystemFailure)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemFactoryMock, createOcdmSystem(kWidevineKeySystem)).WillOnce(Return(ByMove(std::move(nullptr))));
+    mainThreadWillEnqueueTaskAndWait();
 
-    EXPECT_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(kWidevineKeySystem, m_ocdmSystemFactoryMock,
+    EXPECT_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(kWidevineKeySystem, m_mainThreadFactoryMock,
+                                                                         m_ocdmSystemFactoryMock,
                                                                          m_mediaKeySessionFactoryMock),
                  std::runtime_error);
 }
diff --git a/tests/media/server/main/mediaKeys/DecryptTest.cpp b/tests/media/server/main/mediaKeys/DecryptTest.cpp
index 76c14cb..d33bee3 100644
--- a/tests/media/server/main/mediaKeys/DecryptTest.cpp
+++ b/tests/media/server/main/mediaKeys/DecryptTest.cpp
@@ -34,6 +34,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysDecryptTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -41,11 +42,12 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysDecryptTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock,
                 decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId, m_initWithLast15))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->decrypt(m_keySessionId, &m_encrypted, &m_subSample,
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->decrypt(m_kKeySessionId, &m_encrypted, &m_subSample,
                                                             m_subSampleCount, &m_IV, &m_keyId, m_initWithLast15));
 }
 
@@ -54,8 +56,9 @@ TEST_F(RialtoServerMediaKeysDecryptTest, Success)
  */
 TEST_F(RialtoServerMediaKeysDecryptTest, SessionDoesNotExistFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID,
-              m_mediaKeys->decrypt(m_keySessionId + 1, &m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId,
+              m_mediaKeys->decrypt(m_kKeySessionId + 1, &m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId,
                                    m_initWithLast15));
 }
 
@@ -64,11 +67,12 @@ TEST_F(RialtoServerMediaKeysDecryptTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysDecryptTest, DecryptFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock,
                 decrypt(&m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId, m_initWithLast15))
         .WillOnce(Return(MediaKeyErrorStatus::INVALID_STATE));
 
     EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE,
-              m_mediaKeys->decrypt(m_keySessionId, &m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId,
+              m_mediaKeys->decrypt(m_kKeySessionId, &m_encrypted, &m_subSample, m_subSampleCount, &m_IV, &m_keyId,
                                    m_initWithLast15));
 }
diff --git a/tests/media/server/main/mediaKeys/GenerateRequestTest.cpp b/tests/media/server/main/mediaKeys/GenerateRequestTest.cpp
index 355818c..d69ac3c 100644
--- a/tests/media/server/main/mediaKeys/GenerateRequestTest.cpp
+++ b/tests/media/server/main/mediaKeys/GenerateRequestTest.cpp
@@ -30,6 +30,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysGenerateRequestTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -37,10 +38,11 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysGenerateRequestTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, generateRequest(m_initDataType, m_initData))
         .WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->generateRequest(m_keySessionId, m_initDataType, m_initData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->generateRequest(m_kKeySessionId, m_initDataType, m_initData));
 }
 
 /**
@@ -48,8 +50,9 @@ TEST_F(RialtoServerMediaKeysGenerateRequestTest, Success)
  */
 TEST_F(RialtoServerMediaKeysGenerateRequestTest, SessionDoesNotExistFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID,
-              m_mediaKeys->generateRequest(m_keySessionId + 1, m_initDataType, m_initData));
+              m_mediaKeys->generateRequest(m_kKeySessionId + 1, m_initDataType, m_initData));
 }
 
 /**
@@ -57,9 +60,10 @@ TEST_F(RialtoServerMediaKeysGenerateRequestTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysGenerateRequestTest, SessionFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, generateRequest(m_initDataType, m_initData))
         .WillOnce(Return(MediaKeyErrorStatus::NOT_SUPPORTED));
 
     EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED,
-              m_mediaKeys->generateRequest(m_keySessionId, m_initDataType, m_initData));
+              m_mediaKeys->generateRequest(m_kKeySessionId, m_initDataType, m_initData));
 }
diff --git a/tests/media/server/main/mediaKeys/LoadSessionTest.cpp b/tests/media/server/main/mediaKeys/LoadSessionTest.cpp
index bbc3214..d808c1b 100644
--- a/tests/media/server/main/mediaKeys/LoadSessionTest.cpp
+++ b/tests/media/server/main/mediaKeys/LoadSessionTest.cpp
@@ -27,6 +27,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysLoadSessionTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -34,9 +35,10 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysLoadSessionTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, loadSession()).WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->loadSession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->loadSession(m_kKeySessionId));
 }
 
 /**
@@ -44,7 +46,8 @@ TEST_F(RialtoServerMediaKeysLoadSessionTest, Success)
  */
 TEST_F(RialtoServerMediaKeysLoadSessionTest, SessionDoesNotExistFailure)
 {
-    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->loadSession(m_keySessionId + 1));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->loadSession(m_kKeySessionId + 1));
 }
 
 /**
@@ -52,7 +55,8 @@ TEST_F(RialtoServerMediaKeysLoadSessionTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysLoadSessionTest, SessionFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, loadSession()).WillOnce(Return(MediaKeyErrorStatus::NOT_SUPPORTED));
 
-    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeys->loadSession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeys->loadSession(m_kKeySessionId));
 }
diff --git a/tests/media/server/main/mediaKeys/RemoveKeySessionTest.cpp b/tests/media/server/main/mediaKeys/RemoveKeySessionTest.cpp
index e4e70e8..3133450 100644
--- a/tests/media/server/main/mediaKeys/RemoveKeySessionTest.cpp
+++ b/tests/media/server/main/mediaKeys/RemoveKeySessionTest.cpp
@@ -27,6 +27,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysRemoveKeySessionTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -34,9 +35,10 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysRemoveKeySessionTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, removeKeySession()).WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->removeKeySession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->removeKeySession(m_kKeySessionId));
 }
 
 /**
@@ -44,7 +46,8 @@ TEST_F(RialtoServerMediaKeysRemoveKeySessionTest, Success)
  */
 TEST_F(RialtoServerMediaKeysRemoveKeySessionTest, SessionDoesNotExistFailure)
 {
-    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->removeKeySession(m_keySessionId + 1));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->removeKeySession(m_kKeySessionId + 1));
 }
 
 /**
@@ -52,7 +55,8 @@ TEST_F(RialtoServerMediaKeysRemoveKeySessionTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysRemoveKeySessionTest, SessionFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, removeKeySession()).WillOnce(Return(MediaKeyErrorStatus::NOT_SUPPORTED));
 
-    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeys->removeKeySession(m_keySessionId));
+    EXPECT_EQ(MediaKeyErrorStatus::NOT_SUPPORTED, m_mediaKeys->removeKeySession(m_kKeySessionId));
 }
diff --git a/tests/media/server/main/mediaKeys/UpdateSessionTest.cpp b/tests/media/server/main/mediaKeys/UpdateSessionTest.cpp
index d50e4fc..a5f3078 100644
--- a/tests/media/server/main/mediaKeys/UpdateSessionTest.cpp
+++ b/tests/media/server/main/mediaKeys/UpdateSessionTest.cpp
@@ -29,6 +29,7 @@ protected:
         createMediaKeys(kNetflixKeySystem);
         createKeySession(kNetflixKeySystem);
     }
+    ~RialtoServerMediaKeysUpdateSessionTest() { destroyMediaKeys(); }
 };
 
 /**
@@ -36,9 +37,10 @@ protected:
  */
 TEST_F(RialtoServerMediaKeysUpdateSessionTest, Success)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, updateSession(m_responseData)).WillOnce(Return(MediaKeyErrorStatus::OK));
 
-    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->updateSession(m_keySessionId, m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::OK, m_mediaKeys->updateSession(m_kKeySessionId, m_responseData));
 }
 
 /**
@@ -46,7 +48,8 @@ TEST_F(RialtoServerMediaKeysUpdateSessionTest, Success)
  */
 TEST_F(RialtoServerMediaKeysUpdateSessionTest, SessionDoesNotExistFailure)
 {
-    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->updateSession(m_keySessionId + 1, m_responseData));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_EQ(MediaKeyErrorStatus::BAD_SESSION_ID, m_mediaKeys->updateSession(m_kKeySessionId + 1, m_responseData));
 }
 
 /**
@@ -54,7 +57,8 @@ TEST_F(RialtoServerMediaKeysUpdateSessionTest, SessionDoesNotExistFailure)
  */
 TEST_F(RialtoServerMediaKeysUpdateSessionTest, SessionFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionMock, updateSession(m_responseData)).WillOnce(Return(MediaKeyErrorStatus::INVALID_STATE));
 
-    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeys->updateSession(m_keySessionId, m_responseData));
+    EXPECT_EQ(MediaKeyErrorStatus::INVALID_STATE, m_mediaKeys->updateSession(m_kKeySessionId, m_responseData));
 }
diff --git a/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.cpp b/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.cpp
index a7b50e5..ab24425 100644
--- a/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.cpp
+++ b/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.cpp
@@ -28,7 +28,9 @@ MediaKeysTestBase::MediaKeysTestBase()
       m_mediaKeySession{std::make_unique<StrictMock<MediaKeySessionMock>>()},
       m_mediaKeySessionMock{m_mediaKeySession.get()},
       m_ocdmSystemFactoryMock{std::make_shared<StrictMock<OcdmSystemFactoryMock>>()},
-      m_ocdmSystem{std::make_unique<StrictMock<OcdmSystemMock>>()}, m_ocdmSystemMock{m_ocdmSystem.get()}
+      m_ocdmSystem{std::make_unique<StrictMock<OcdmSystemMock>>()}, m_ocdmSystemMock{m_ocdmSystem.get()},
+      m_mainThreadFactoryMock{std::make_shared<StrictMock<MainThreadFactoryMock>>()},
+      m_mainThreadMock{std::make_shared<StrictMock<MainThreadMock>>()}
 {
 }
 
@@ -36,18 +38,39 @@ MediaKeysTestBase::~MediaKeysTestBase() {}
 
 void MediaKeysTestBase::createMediaKeys(std::string keySystem)
 {
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
     EXPECT_CALL(*m_ocdmSystemFactoryMock, createOcdmSystem(keySystem)).WillOnce(Return(ByMove(std::move(m_ocdmSystem))));
+    mainThreadWillEnqueueTaskAndWait();
 
-    EXPECT_NO_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(keySystem, m_ocdmSystemFactoryMock,
+    EXPECT_NO_THROW(m_mediaKeys = std::make_unique<MediaKeysServerInternal>(keySystem, m_mainThreadFactoryMock,
+                                                                            m_ocdmSystemFactoryMock,
                                                                             m_mediaKeySessionFactoryMock));
     EXPECT_NE(m_mediaKeys, nullptr);
 }
 
+void MediaKeysTestBase::destroyMediaKeys()
+{
+    EXPECT_CALL(*m_mainThreadMock, unregisterClient(m_kMainThreadClientId));
+    // Objects are destroyed on the main thread
+    mainThreadWillEnqueueTaskAndWait();
+
+    m_mediaKeys.reset();
+}
+
 void MediaKeysTestBase::createKeySession(std::string keySystem)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_mediaKeySessionFactoryMock, createMediaKeySession(keySystem, _, _, m_keySessionType, _, m_isLDL))
         .WillOnce(Return(ByMove(std::move(m_mediaKeySession))));
 
     EXPECT_EQ(MediaKeyErrorStatus::OK,
-              m_mediaKeys->createKeySession(m_keySessionType, m_mediaKeysClientMock, m_isLDL, m_keySessionId));
+              m_mediaKeys->createKeySession(m_keySessionType, m_mediaKeysClientMock, m_isLDL, m_kKeySessionId));
+}
+
+void MediaKeysTestBase::mainThreadWillEnqueueTaskAndWait()
+{
+    EXPECT_CALL(*m_mainThreadMock, enqueueTaskAndWait(m_kMainThreadClientId, _))
+        .WillOnce(Invoke([](uint32_t clientId, firebolt::rialto::server::IMainThread::Task task) { task(); }))
+        .RetiresOnSaturation();
 }
diff --git a/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.h b/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.h
index 056aa05..ad38e70 100644
--- a/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.h
+++ b/tests/media/server/main/mediaKeys/base/MediaKeysTestBase.h
@@ -20,6 +20,8 @@
 #ifndef MEDIA_KEYS_TEST_BASE_H_
 #define MEDIA_KEYS_TEST_BASE_H_
 
+#include "MainThreadFactoryMock.h"
+#include "MainThreadMock.h"
 #include "MediaKeySessionFactoryMock.h"
 #include "MediaKeySessionMock.h"
 #include "MediaKeysClientMock.h"
@@ -38,6 +40,7 @@ using namespace firebolt::rialto::server::mock;
 
 using ::testing::_;
 using ::testing::ByMove;
+using ::testing::Invoke;
 using ::testing::Return;
 using ::testing::StrictMock;
 
@@ -59,15 +62,20 @@ protected:
     std::shared_ptr<StrictMock<OcdmSystemFactoryMock>> m_ocdmSystemFactoryMock;
     std::unique_ptr<StrictMock<OcdmSystemMock>> m_ocdmSystem;
     StrictMock<OcdmSystemMock> *m_ocdmSystemMock;
+    std::shared_ptr<StrictMock<MainThreadFactoryMock>> m_mainThreadFactoryMock;
+    std::shared_ptr<StrictMock<MainThreadMock>> m_mainThreadMock;
 
     // Common variables
     int32_t m_mediaKeysHandle = 123;
+    const int32_t m_kMainThreadClientId = {5};
     KeySessionType m_keySessionType = KeySessionType::PERSISTENT_RELEASE_MESSAGE;
     bool m_isLDL = false;
-    int32_t m_keySessionId = -1;
+    int32_t m_kKeySessionId = -1;
 
     void createMediaKeys(std::string keySystem);
+    void destroyMediaKeys();
     void createKeySession(std::string keySystem);
+    void mainThreadWillEnqueueTaskAndWait();
 };
 
 #endif // MEDIA_KEYS_TEST_BASE_H_
diff --git a/tests/media/server/main/mediaPipeline/CallbackTest.cpp b/tests/media/server/main/mediaPipeline/CallbackTest.cpp
index 62df07c..f38d3c2 100644
--- a/tests/media/server/main/mediaPipeline/CallbackTest.cpp
+++ b/tests/media/server/main/mediaPipeline/CallbackTest.cpp
@@ -17,94 +17,41 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "GstPlayerMock.h"
 #include "IGstPlayerClient.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::_;
 using ::testing::ByMove;
 using ::testing::DoAll;
-using ::testing::Return;
 using ::testing::SaveArg;
-using ::testing::StrictMock;
 
 MATCHER_P(QosInfoMatcher, expectedQosInfo, "")
 {
     return ((expectedQosInfo.processed == arg.processed) && (expectedQosInfo.dropped == arg.dropped));
 }
 
-class RialtoServerMediaPipelineCallbackTest : public ::testing::Test
+class RialtoServerMediaPipelineCallbackTest : public MediaPipelineTestBase
 {
 protected:
-    std::shared_ptr<StrictMock<MediaPipelineClientMock>> m_mediaPipelineClient;
     IGstPlayerClient *m_gstPlayerCallback;
-    std::unique_ptr<IMediaPipelineServerInternal> m_mediaPipeline;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    std::unique_ptr<StrictMock<GstPlayerMock>> m_gstPlayerMock;
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequests;
-    StrictMock<ActiveRequestsMock> *m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
-    const int m_kSessionId{1};
-
-    virtual void SetUp()
-    {
-        m_mediaPipelineClient = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_gstPlayerMock = std::make_unique<StrictMock<GstPlayerMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-        m_activeRequests = std::make_unique<StrictMock<ActiveRequestsMock>>();
-        m_activeRequestsMock = static_cast<StrictMock<ActiveRequestsMock> *>(m_activeRequests.get());
 
+    RialtoServerMediaPipelineCallbackTest()
+    {
         createMediaPipeline();
 
         GetGstPlayerClient();
     }
 
-    virtual void TearDown()
-    {
-        EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
-        m_mediaPipeline.reset();
-
-        m_gstPlayerMock.reset();
-        m_gstPlayerFactoryMock.reset();
-
-        m_mediaPipelineClient.reset();
-    }
-
-    void createMediaPipeline()
-    {
-        VideoRequirements videoReq = {};
-
-        EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
-
-        EXPECT_NO_THROW(
-            m_mediaPipeline =
-                std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClient, videoReq, m_gstPlayerFactoryMock,
-                                                              m_kSessionId, m_sharedMemoryBufferMock,
-                                                              std::move(m_dataReaderFactoryMock),
-                                                              std::move(m_activeRequests), m_decryptionServiceMock););
-        EXPECT_NE(m_mediaPipeline, nullptr);
-    }
+    ~RialtoServerMediaPipelineCallbackTest() { destroyMediaPipeline(); }
 
     void GetGstPlayerClient()
     {
+        mainThreadWillEnqueueTaskAndWait();
         EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, _))
-            .WillOnce(DoAll(SaveArg<0>(&m_gstPlayerCallback), Return(ByMove(std::move(m_gstPlayerMock)))));
-        EXPECT_CALL(*m_mediaPipelineClient, notifyNetworkState(NetworkState::BUFFERING));
+            .WillOnce(DoAll(SaveArg<0>(&m_gstPlayerCallback), Return(ByMove(std::move(m_gstPlayer)))));
+
+        // notifyNetworkState posts a task onto the main thread but doesnt wait
+        mainThreadWillEnqueueTask();
+        EXPECT_CALL(*m_mediaPipelineClientMock, notifyNetworkState(NetworkState::BUFFERING));
 
         EXPECT_EQ(m_mediaPipeline->load(MediaType::MSE, "mime", "mse://1"), true);
 
@@ -118,7 +65,8 @@ protected:
 TEST_F(RialtoServerMediaPipelineCallbackTest, NotifyPlaybackState)
 {
     PlaybackState state = PlaybackState::IDLE;
-    EXPECT_CALL(*m_mediaPipelineClient, notifyPlaybackState(state));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyPlaybackState(state));
 
     m_gstPlayerCallback->notifyPlaybackState(state);
 }
@@ -129,7 +77,8 @@ TEST_F(RialtoServerMediaPipelineCallbackTest, NotifyPlaybackState)
 TEST_F(RialtoServerMediaPipelineCallbackTest, notifyPosition)
 {
     int64_t position{12345};
-    EXPECT_CALL(*m_mediaPipelineClient, notifyPosition(position));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyPosition(position));
 
     m_gstPlayerCallback->notifyPosition(position);
 }
@@ -140,7 +89,8 @@ TEST_F(RialtoServerMediaPipelineCallbackTest, notifyPosition)
 TEST_F(RialtoServerMediaPipelineCallbackTest, notifyNetworkState)
 {
     auto state{firebolt::rialto::NetworkState::BUFFERING};
-    EXPECT_CALL(*m_mediaPipelineClient, notifyNetworkState(state));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyNetworkState(state));
 
     m_gstPlayerCallback->notifyNetworkState(state);
 }
@@ -153,13 +103,14 @@ TEST_F(RialtoServerMediaPipelineCallbackTest, notifyNeedMediaData)
     auto mediaSourceType = firebolt::rialto::MediaSourceType::VIDEO;
     int sourceId{static_cast<int>(firebolt::rialto::MediaSourceType::VIDEO)};
     int numFrames{24};
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_sharedMemoryBufferMock);
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_sharedMemoryBufferMock, clearBuffer(m_kSessionId, mediaSourceType)).WillOnce(Return(true));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferLen(m_kSessionId, mediaSourceType)).WillOnce(Return(7 * 1024 * 1024));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferOffset(m_kSessionId, mediaSourceType)).WillOnce(Return(0));
     EXPECT_CALL(*m_activeRequestsMock, insert(mediaSourceType, _)).WillOnce(Return(0));
-    EXPECT_CALL(*m_mediaPipelineClient,
+    EXPECT_CALL(*m_mediaPipelineClientMock,
                 notifyNeedMediaData(sourceId, numFrames, 0, _)); // params tested in NeedMediaDataTests
 
     m_gstPlayerCallback->notifyNeedMediaData(mediaSourceType);
@@ -174,7 +125,8 @@ TEST_F(RialtoServerMediaPipelineCallbackTest, notifyQos)
     int sourceId{static_cast<int>(firebolt::rialto::MediaSourceType::VIDEO)};
     QosInfo qosInfo{5u, 2u};
 
-    EXPECT_CALL(*m_mediaPipelineClient, notifyQos(sourceId, QosInfoMatcher(qosInfo)));
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyQos(sourceId, QosInfoMatcher(qosInfo)));
 
     m_gstPlayerCallback->notifyQos(mediaSourceType, qosInfo);
 }
@@ -184,6 +136,7 @@ TEST_F(RialtoServerMediaPipelineCallbackTest, notifyQos)
  */
 TEST_F(RialtoServerMediaPipelineCallbackTest, clearActiveRequestsCache)
 {
+    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_activeRequestsMock, clear());
 
     m_gstPlayerCallback->clearActiveRequestsCache();
diff --git a/tests/media/server/main/mediaPipeline/CreateTest.cpp b/tests/media/server/main/mediaPipeline/CreateTest.cpp
index 9d4ee41..ac370c1 100644
--- a/tests/media/server/main/mediaPipeline/CreateTest.cpp
+++ b/tests/media/server/main/mediaPipeline/CreateTest.cpp
@@ -17,52 +17,10 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::Return;
-using ::testing::StrictMock;
-
-namespace
+class RialtoServerCreateMediaPipelineTest : public MediaPipelineTestBase
 {
-constexpr int sessionId{1};
-} // namespace
-
-class RialtoServerCreateMediaPipelineTest : public ::testing::Test
-{
-protected:
-    std::shared_ptr<IMediaPipelineClient> m_mediaPipelineClient;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    VideoRequirements m_videoReq = {};
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
-
-    virtual void SetUp()
-    {
-        m_mediaPipelineClient = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-    }
-
-    virtual void TearDown()
-    {
-        m_gstPlayerFactoryMock.reset();
-
-        m_mediaPipelineClient.reset();
-    }
 };
 
 /**
@@ -70,15 +28,20 @@ protected:
  */
 TEST_F(RialtoServerCreateMediaPipelineTest, Create)
 {
-    std::unique_ptr<IMediaPipeline> mediaPipeline;
-
-    EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(sessionId)).WillOnce(Return(true));
-    EXPECT_NO_THROW(mediaPipeline = std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClient, m_videoReq,
-                                                                                  m_gstPlayerFactoryMock, sessionId,
-                                                                                  m_sharedMemoryBufferMock,
-                                                                                  std::move(m_dataReaderFactoryMock),
-                                                                                  std::move(m_activeRequestsMock),
-                                                                                  m_decryptionServiceMock););
-    EXPECT_NE(mediaPipeline, nullptr);
-    EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(sessionId)).WillOnce(Return(true));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
+    EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
+    EXPECT_NO_THROW(
+        m_mediaPipeline =
+            std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClientMock, m_videoReq, m_gstPlayerFactoryMock,
+                                                          m_kSessionId, m_sharedMemoryBufferMock,
+                                                          m_mainThreadFactoryMock, std::move(m_dataReaderFactory),
+                                                          std::move(m_activeRequests), m_decryptionServiceMock););
+    EXPECT_NE(m_mediaPipeline, nullptr);
+
+    EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
+    EXPECT_CALL(*m_mainThreadMock, unregisterClient(m_kMainThreadClientId));
+    // Objects are destroyed on the main thread
+    mainThreadWillEnqueueTaskAndWait();
 }
diff --git a/tests/media/server/main/mediaPipeline/HaveDataTest.cpp b/tests/media/server/main/mediaPipeline/HaveDataTest.cpp
index 0c2dbdb..14cb981 100644
--- a/tests/media/server/main/mediaPipeline/HaveDataTest.cpp
+++ b/tests/media/server/main/mediaPipeline/HaveDataTest.cpp
@@ -17,130 +17,50 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DataReaderMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "GstPlayerMock.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::_;
 using ::testing::A;
 using ::testing::ByMove;
 using ::testing::Ref;
-using ::testing::Return;
 using ::testing::ReturnRef;
-using ::testing::StrictMock;
 using ::testing::Throw;
 
-class RialtoServerMediaPipelineHaveDataTest : public ::testing::Test
+class RialtoServerMediaPipelineHaveDataTest : public MediaPipelineTestBase
 {
 protected:
-    std::shared_ptr<StrictMock<MediaPipelineClientMock>> m_mediaPipelineClient;
-    std::unique_ptr<IMediaPipelineServerInternal> m_mediaPipeline;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    StrictMock<GstPlayerMock> *m_gstPlayerMock = nullptr;
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactory;
-    StrictMock<DataReaderFactoryMock> *m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequests;
-    StrictMock<ActiveRequestsMock> *m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
-    const int m_kSessionId{1};
     const uint32_t m_kNumFrames{24};
     const uint32_t m_kNeedDataRequestId{0};
 
-    virtual void SetUp()
-    {
-        m_mediaPipelineClient = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-
-        m_activeRequests = std::make_unique<StrictMock<ActiveRequestsMock>>();
-        m_activeRequestsMock = static_cast<StrictMock<ActiveRequestsMock> *>(m_activeRequests.get());
-
-        m_dataReaderFactory = std::make_unique<StrictMock<DataReaderFactoryMock>>();
-        m_dataReaderFactoryMock = static_cast<StrictMock<DataReaderFactoryMock> *>(m_dataReaderFactory.get());
-
-        createMediaPipeline();
-    }
-
-    virtual void TearDown()
-    {
-        EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
-        m_mediaPipeline.reset();
-
-        m_gstPlayerFactoryMock.reset();
-        m_gstPlayerMock = nullptr;
-
-        m_mediaPipelineClient.reset();
-    }
-
-    void createMediaPipeline()
-    {
-        VideoRequirements videoReq = {};
-
-        EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
-        EXPECT_NO_THROW(
-            m_mediaPipeline =
-                std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClient, videoReq, m_gstPlayerFactoryMock,
-                                                              m_kSessionId, m_sharedMemoryBufferMock,
-                                                              std::move(m_dataReaderFactory),
-                                                              std::move(m_activeRequests), m_decryptionServiceMock););
-        EXPECT_NE(m_mediaPipeline, nullptr);
-    }
-
-    void LoadGstPlayer()
-    {
-        std::unique_ptr<StrictMock<GstPlayerMock>> gstPlayerMock = std::make_unique<StrictMock<GstPlayerMock>>();
-
-        // Save a raw pointer to the unique object for use when testing mocks
-        // Object shall be freed by the holder of the unique ptr on destruction
-        m_gstPlayerMock = gstPlayerMock.get();
-
-        EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, _)).WillOnce(Return(ByMove(std::move(gstPlayerMock))));
-        MediaPipelineClientMock &mediaPipelineClientMock =
-            dynamic_cast<StrictMock<MediaPipelineClientMock> &>(*m_mediaPipelineClient);
-        EXPECT_CALL(mediaPipelineClientMock, notifyNetworkState(NetworkState::BUFFERING));
+    RialtoServerMediaPipelineHaveDataTest() { createMediaPipeline(); }
 
-        EXPECT_EQ(m_mediaPipeline->load(MediaType::MSE, "mime", "mse://1"), true);
-    }
+    ~RialtoServerMediaPipelineHaveDataTest() { destroyMediaPipeline(); }
 };
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataFailureDueToUninitializedPlayer)
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
-    EXPECT_FALSE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccessWithUnknownRequestId)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::UNKNOWN));
     auto status = firebolt::rialto::MediaSourceStatus::OK;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
-    EXPECT_TRUE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    EXPECT_TRUE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccessWithNeedMediaDataResend)
 {
     auto status = firebolt::rialto::MediaSourceStatus::ERROR;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
     auto mediaSourceType = firebolt::rialto::MediaSourceType::VIDEO;
     int sourceId{static_cast<int>(mediaSourceType)};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId)).WillOnce(Return(mediaSourceType));
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
@@ -150,47 +70,47 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccessWithNeedMedia
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferLen(m_kSessionId, mediaSourceType)).WillOnce(Return(7 * 1024 * 1024));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferOffset(m_kSessionId, mediaSourceType)).WillOnce(Return(0));
     EXPECT_CALL(*m_activeRequestsMock, insert(mediaSourceType, _)).WillOnce(Return(0));
-    EXPECT_CALL(*m_mediaPipelineClient,
+    EXPECT_CALL(*m_mediaPipelineClientMock,
                 notifyNeedMediaData(sourceId, m_kNumFrames, 0, _)); // params tested in NeedMediaDataTests
-    EXPECT_TRUE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    EXPECT_TRUE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataGettingSamplesThrows)
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
     IMediaPipeline::MediaSegmentVector dataVec;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
     EXPECT_CALL(*m_activeRequestsMock, getSegments(m_kNeedDataRequestId))
         .WillOnce(Throw(std::runtime_error("runtime_error")));
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
-    EXPECT_FALSE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccess)
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
     IMediaPipeline::MediaSegmentVector dataVec;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
     EXPECT_CALL(*m_activeRequestsMock, getSegments(m_kNeedDataRequestId)).WillOnce(ReturnRef(dataVec));
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
     EXPECT_CALL(*m_gstPlayerMock, attachSamples(A<const IMediaPipeline::MediaSegmentVector &>()));
-    EXPECT_TRUE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    EXPECT_TRUE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccessEos)
 {
     auto status = firebolt::rialto::MediaSourceStatus::EOS;
     IMediaPipeline::MediaSegmentVector dataVec;
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
@@ -198,48 +118,50 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, CommonHaveDataSuccessEos)
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
     EXPECT_CALL(*m_gstPlayerMock, attachSamples(A<const IMediaPipeline::MediaSegmentVector &>()));
     EXPECT_CALL(*m_gstPlayerMock, setEos(firebolt::rialto::MediaSourceType::VIDEO));
-    EXPECT_TRUE(mediaPipeline->haveData(status, m_kNeedDataRequestId));
+    EXPECT_TRUE(m_mediaPipeline->haveData(status, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, AddSegmentReturnsError)
 {
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
     std::unique_ptr<IMediaPipeline::MediaSegment> segment = std::make_unique<IMediaPipeline::MediaSegment>();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, addSegment(m_kNeedDataRequestId, Ref(segment)))
         .WillOnce(Return(AddSegmentStatus::ERROR));
-    EXPECT_EQ(mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::ERROR);
+    EXPECT_EQ(m_mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::ERROR);
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, AddSegmentReturnsNoSpace)
 {
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
     std::unique_ptr<IMediaPipeline::MediaSegment> segment = std::make_unique<IMediaPipeline::MediaSegment>();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, addSegment(m_kNeedDataRequestId, Ref(segment)))
         .WillOnce(Return(AddSegmentStatus::NO_SPACE));
-    EXPECT_EQ(mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::NO_SPACE);
+    EXPECT_EQ(m_mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::NO_SPACE);
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, AddSegmentSuccess)
 {
-    IMediaPipeline *mediaPipeline = m_mediaPipeline.get();
     std::unique_ptr<IMediaPipeline::MediaSegment> segment = std::make_unique<IMediaPipeline::MediaSegment>();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, addSegment(m_kNeedDataRequestId, Ref(segment)))
         .WillOnce(Return(AddSegmentStatus::OK));
-    EXPECT_EQ(mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::OK);
+    EXPECT_EQ(m_mediaPipeline->addSegment(m_kNeedDataRequestId, segment), AddSegmentStatus::OK);
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueToUninitializedPlayer)
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNumFrames, m_kNeedDataRequestId));
 }
 
 TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessWithUnknownRequestId)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::UNKNOWN));
@@ -252,7 +174,8 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessWithN
     auto status = firebolt::rialto::MediaSourceStatus::ERROR;
     auto mediaSourceType = firebolt::rialto::MediaSourceType::VIDEO;
     int sourceId{static_cast<int>(mediaSourceType)};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId)).WillOnce(Return(mediaSourceType));
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
@@ -262,7 +185,7 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessWithN
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferLen(m_kSessionId, mediaSourceType)).WillOnce(Return(7 * 1024 * 1024));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferOffset(m_kSessionId, mediaSourceType)).WillOnce(Return(0));
     EXPECT_CALL(*m_activeRequestsMock, insert(mediaSourceType, _)).WillOnce(Return(0));
-    EXPECT_CALL(*m_mediaPipelineClient,
+    EXPECT_CALL(*m_mediaPipelineClientMock,
                 notifyNeedMediaData(sourceId, m_kNumFrames, 0, _)); // params tested in NeedMediaDataTests
     EXPECT_TRUE(m_mediaPipeline->haveData(status, m_kNumFrames, m_kNeedDataRequestId));
 }
@@ -270,13 +193,15 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessWithN
 TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueToShmBufferError)
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
+    mainThreadWillEnqueueTask();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
     EXPECT_CALL(*m_activeRequestsMock, erase(m_kNeedDataRequestId));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferForSession(m_kSessionId)).WillOnce(Return(nullptr));
-    EXPECT_CALL(*m_mediaPipelineClient, notifyPlaybackState(PlaybackState::FAILURE));
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyPlaybackState(PlaybackState::FAILURE));
     EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNumFrames, m_kNeedDataRequestId));
 }
 
@@ -284,7 +209,9 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueTo
 {
     auto status = firebolt::rialto::MediaSourceStatus::OK;
     std::uint8_t data{123};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
+    mainThreadWillEnqueueTask();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
@@ -292,7 +219,7 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueTo
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferForSession(m_kSessionId)).WillOnce(Return(&data));
     EXPECT_CALL(*m_sharedMemoryBufferMock, getBufferOffset(m_kSessionId, firebolt::rialto::MediaSourceType::VIDEO))
         .WillOnce(Throw(std::runtime_error("runtime_error")));
-    EXPECT_CALL(*m_mediaPipelineClient, notifyPlaybackState(PlaybackState::FAILURE));
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyPlaybackState(PlaybackState::FAILURE));
     EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNumFrames, m_kNeedDataRequestId));
 }
 
@@ -302,7 +229,9 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueTo
     std::uint8_t data{123};
     int offset = 0;
     std::shared_ptr<IDataReader> dataReader;
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
+    mainThreadWillEnqueueTask();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
@@ -313,7 +242,7 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataFailureDueTo
     EXPECT_CALL(*m_dataReaderFactoryMock,
                 createDataReader(firebolt::rialto::MediaSourceType::VIDEO, &data, offset, m_kNumFrames))
         .WillOnce(Return(dataReader));
-    EXPECT_CALL(*m_mediaPipelineClient, notifyPlaybackState(PlaybackState::FAILURE));
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyPlaybackState(PlaybackState::FAILURE));
     EXPECT_FALSE(m_mediaPipeline->haveData(status, m_kNumFrames, m_kNeedDataRequestId));
 }
 
@@ -323,7 +252,8 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccess)
     std::uint8_t data{123};
     int offset = 0;
     std::shared_ptr<IDataReader> dataReader{std::make_shared<DataReaderMock>()};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
@@ -344,7 +274,8 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataAudioSuccess
     std::uint8_t data{123};
     int offset = 64;
     std::shared_ptr<IDataReader> dataReader{std::make_shared<DataReaderMock>()};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::AUDIO));
@@ -365,7 +296,8 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessWithE
     std::uint8_t data{123};
     int offset = 0;
     std::shared_ptr<IDataReader> dataReader{std::make_shared<DataReaderMock>()};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
@@ -387,7 +319,8 @@ TEST_F(RialtoServerMediaPipelineHaveDataTest, ServerInternalHaveDataSuccessEosWi
     std::uint8_t data{123};
     int offset = 0;
     std::shared_ptr<IDataReader> dataReader{std::make_shared<DataReaderMock>()};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     ASSERT_TRUE(m_activeRequestsMock);
     EXPECT_CALL(*m_activeRequestsMock, getType(m_kNeedDataRequestId))
         .WillOnce(Return(firebolt::rialto::MediaSourceType::VIDEO));
diff --git a/tests/media/server/main/mediaPipeline/LoadTest.cpp b/tests/media/server/main/mediaPipeline/LoadTest.cpp
index 24ee8c6..a9ac60b 100644
--- a/tests/media/server/main/mediaPipeline/LoadTest.cpp
+++ b/tests/media/server/main/mediaPipeline/LoadTest.cpp
@@ -17,77 +17,20 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "GstPlayerMock.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::_;
 using ::testing::ByMove;
-using ::testing::Return;
-using ::testing::StrictMock;
 
-class RialtoServerMediaPipelineLoadTest : public ::testing::Test
+class RialtoServerMediaPipelineLoadTest : public MediaPipelineTestBase
 {
 protected:
-    std::shared_ptr<StrictMock<MediaPipelineClientMock>> m_mediaPipelineClientMock;
-    std::unique_ptr<IMediaPipeline> m_mediaPipeline;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    std::unique_ptr<StrictMock<GstPlayerMock>> m_gstPlayerMock;
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
     MediaType m_type = MediaType::MSE;
-    const int m_kSessionId{1};
     const std::string m_kMimeType = "mime";
     const std::string m_kUrl = "mse://1";
 
-    virtual void SetUp()
-    {
-        m_mediaPipelineClientMock = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_gstPlayerMock = std::make_unique<StrictMock<GstPlayerMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-
-        createMediaPipeline();
-    }
-
-    virtual void TearDown()
-    {
-        EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
-        m_mediaPipeline.reset();
-
-        m_gstPlayerMock.reset();
-        m_gstPlayerFactoryMock.reset();
-
-        m_mediaPipelineClientMock.reset();
-    }
-
-    void createMediaPipeline()
-    {
-        VideoRequirements videoReq = {};
+    RialtoServerMediaPipelineLoadTest() { createMediaPipeline(); }
 
-        EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
-        EXPECT_NO_THROW(
-            m_mediaPipeline = std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClientMock, videoReq,
-                                                                            m_gstPlayerFactoryMock, m_kSessionId,
-                                                                            m_sharedMemoryBufferMock,
-                                                                            std::move(m_dataReaderFactoryMock),
-                                                                            std::move(m_activeRequestsMock),
-                                                                            m_decryptionServiceMock););
-        EXPECT_NE(m_mediaPipeline, nullptr);
-    }
+    ~RialtoServerMediaPipelineLoadTest() { destroyMediaPipeline(); }
 };
 
 /**
@@ -95,7 +38,9 @@ protected:
  */
 TEST_F(RialtoServerMediaPipelineLoadTest, Success)
 {
-    EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, m_type)).WillOnce(Return(ByMove(std::move(m_gstPlayerMock))));
+    mainThreadWillEnqueueTaskAndWait();
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, m_type)).WillOnce(Return(ByMove(std::move(m_gstPlayer))));
     EXPECT_CALL(*m_mediaPipelineClientMock, notifyNetworkState(NetworkState::BUFFERING));
 
     EXPECT_EQ(m_mediaPipeline->load(m_type, m_kMimeType, m_kUrl), true);
@@ -107,6 +52,7 @@ TEST_F(RialtoServerMediaPipelineLoadTest, Success)
  */
 TEST_F(RialtoServerMediaPipelineLoadTest, CreateGstPlayerFailure)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, m_type)).WillOnce(Return(ByMove(nullptr)));
     EXPECT_CALL(*m_mediaPipelineClientMock, notifyNetworkState(_)).Times(0);
 
diff --git a/tests/media/server/main/mediaPipeline/MiscellaneousFunctionsTest.cpp b/tests/media/server/main/mediaPipeline/MiscellaneousFunctionsTest.cpp
index dea2eeb..e6dee0c 100644
--- a/tests/media/server/main/mediaPipeline/MiscellaneousFunctionsTest.cpp
+++ b/tests/media/server/main/mediaPipeline/MiscellaneousFunctionsTest.cpp
@@ -17,91 +17,19 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "GstPlayerMock.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::_;
 using ::testing::ByMove;
-using ::testing::Invoke;
-using ::testing::Return;
-using ::testing::StrictMock;
 
-class RialtoServerMediaPipelineMiscellaneousFunctionsTest : public ::testing::Test
+class RialtoServerMediaPipelineMiscellaneousFunctionsTest : public MediaPipelineTestBase
 {
 protected:
-    std::shared_ptr<IMediaPipelineClient> m_mediaPipelineClient;
-    std::unique_ptr<IMediaPipelineServerInternal> m_mediaPipeline;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    StrictMock<GstPlayerMock> *m_gstPlayerMock = nullptr;
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
-    const int m_kSessionId{1};
     const int64_t m_kPosition{4028596027};
     const double m_kPlaybackRate{1.5};
 
-    virtual void SetUp()
-    {
-        m_mediaPipelineClient = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-
-        createMediaPipeline();
-    }
-
-    virtual void TearDown()
-    {
-        EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
-        m_mediaPipeline.reset();
-
-        m_gstPlayerFactoryMock.reset();
-        m_gstPlayerMock = nullptr;
-
-        m_mediaPipelineClient.reset();
-    }
-
-    void createMediaPipeline()
-    {
-        VideoRequirements videoReq = {};
-
-        EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
-        EXPECT_NO_THROW(
-            m_mediaPipeline =
-                std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClient, videoReq, m_gstPlayerFactoryMock,
-                                                              m_kSessionId, m_sharedMemoryBufferMock,
-                                                              std::move(m_dataReaderFactoryMock),
-                                                              std::move(m_activeRequestsMock), m_decryptionServiceMock););
-        EXPECT_NE(m_mediaPipeline, nullptr);
-    }
-
-    void LoadGstPlayer()
-    {
-        std::unique_ptr<StrictMock<GstPlayerMock>> gstPlayerMock = std::make_unique<StrictMock<GstPlayerMock>>();
-
-        // Save a raw pointer to the unique object for use when testing mocks
-        // Object shall be freed by the holder of the unique ptr on destruction
-        m_gstPlayerMock = gstPlayerMock.get();
-
-        EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, _)).WillOnce(Return(ByMove(std::move(gstPlayerMock))));
-        MediaPipelineClientMock &mediaPipelineClientMock =
-            dynamic_cast<MediaPipelineClientMock &>(*m_mediaPipelineClient);
-        EXPECT_CALL(mediaPipelineClientMock, notifyNetworkState(NetworkState::BUFFERING));
+    RialtoServerMediaPipelineMiscellaneousFunctionsTest() { createMediaPipeline(); }
 
-        EXPECT_EQ(m_mediaPipeline->load(MediaType::MSE, "mime", "mse://1"), true);
-    }
+    ~RialtoServerMediaPipelineMiscellaneousFunctionsTest() { destroyMediaPipeline(); }
 };
 
 /**
@@ -109,7 +37,8 @@ protected:
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PlaySuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, play());
     EXPECT_TRUE(m_mediaPipeline->play());
@@ -120,6 +49,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PlaySuccess)
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PlayFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->play());
 }
 
@@ -128,7 +58,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PlayFailureDueToUnin
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, StopSuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, stop());
     EXPECT_TRUE(m_mediaPipeline->stop());
@@ -139,6 +70,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, StopSuccess)
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, StopFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->stop());
 }
 
@@ -147,7 +79,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, StopFailureDueToUnin
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PauseSuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, pause());
     EXPECT_TRUE(m_mediaPipeline->pause());
@@ -158,6 +91,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PauseSuccess)
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, PauseFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->pause());
 }
 
@@ -170,7 +104,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetVideoWindowSucces
     uint32_t y{4};
     uint32_t width{640};
     uint32_t height{480};
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, setVideoGeometry(x, y, width, height));
     EXPECT_TRUE(m_mediaPipeline->setVideoWindow(x, y, width, height));
@@ -185,6 +120,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetVideoWindowFailur
     uint32_t y{4};
     uint32_t width{640};
     uint32_t height{480};
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->setVideoWindow(x, y, width, height));
 }
 
@@ -193,6 +129,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetVideoWindowFailur
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPositionFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->setPosition(m_kPosition));
 }
 
@@ -201,7 +138,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPositionFailureDu
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPositionSuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, setPosition(m_kPosition));
     EXPECT_TRUE(m_mediaPipeline->setPosition(m_kPosition));
@@ -212,6 +150,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPositionSuccess)
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->setPlaybackRate(m_kPlaybackRate));
 }
 
@@ -220,6 +159,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateFailu
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateFailureDueToWrongRateValue)
 {
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_FALSE(m_mediaPipeline->setPlaybackRate(0.0));
 }
 
@@ -228,7 +168,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateFailu
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateSuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, setPlaybackRate(m_kPlaybackRate));
     EXPECT_TRUE(m_mediaPipeline->setPlaybackRate(m_kPlaybackRate));
@@ -239,6 +180,7 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, SetPlaybackRateSucce
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, GetPositionFailureDueToUninitializedPlayer)
 {
+    mainThreadWillEnqueueTaskAndWait();
     int64_t targetPosition{};
     EXPECT_FALSE(m_mediaPipeline->getPosition(targetPosition));
 }
@@ -248,7 +190,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, GetPositionFailureDu
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, GetPositionFailure)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     int64_t targetPosition{};
     EXPECT_CALL(*m_gstPlayerMock, getPosition(_)).WillOnce(Return(false));
     EXPECT_FALSE(m_mediaPipeline->getPosition(targetPosition));
@@ -259,7 +202,8 @@ TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, GetPositionFailure)
  */
 TEST_F(RialtoServerMediaPipelineMiscellaneousFunctionsTest, GetPositionSuccess)
 {
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
     int64_t targetPosition{};
     EXPECT_CALL(*m_gstPlayerMock, getPosition(_)).WillOnce(Invoke([&](int64_t &pos) {
         pos = m_kPosition;
diff --git a/tests/media/server/main/mediaPipeline/SourceTest.cpp b/tests/media/server/main/mediaPipeline/SourceTest.cpp
index 625ae5b..d4bd744 100644
--- a/tests/media/server/main/mediaPipeline/SourceTest.cpp
+++ b/tests/media/server/main/mediaPipeline/SourceTest.cpp
@@ -17,89 +17,18 @@
  * limitations under the License.
  */
 
-#include "ActiveRequestsMock.h"
-#include "DataReaderFactoryMock.h"
-#include "DecryptionServiceMock.h"
-#include "GstPlayerFactoryMock.h"
-#include "GstPlayerMock.h"
-#include "MediaPipelineClientMock.h"
-#include "MediaPipelineServerInternal.h"
-#include "SharedMemoryBufferMock.h"
-#include <gtest/gtest.h>
+#include "MediaPipelineTestBase.h"
 
-using namespace firebolt::rialto;
-using namespace firebolt::rialto::server;
-using namespace firebolt::rialto::server::mock;
-
-using ::testing::_;
-using ::testing::ByMove;
-using ::testing::Return;
-using ::testing::StrictMock;
-
-class RialtoServerMediaPipelineSourceTest : public ::testing::Test
+class RialtoServerMediaPipelineSourceTest : public MediaPipelineTestBase
 {
 protected:
-    std::shared_ptr<StrictMock<MediaPipelineClientMock>> m_mediaPipelineClient;
-    std::unique_ptr<MediaPipelineServerInternal> m_mediaPipeline;
-    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
-    StrictMock<GstPlayerMock> *m_gstPlayerMock = nullptr;
-    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
-    std::unique_ptr<IDataReaderFactory> m_dataReaderFactoryMock;
-    std::unique_ptr<IActiveRequests> m_activeRequestsMock;
-    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
-    const int m_kSessionId{1};
     int32_t m_id = 456;
     MediaSourceType m_type = MediaSourceType::AUDIO;
     const char *m_kCaps = "CAPS";
 
-    virtual void SetUp()
-    {
-        m_mediaPipelineClient = std::make_shared<StrictMock<MediaPipelineClientMock>>();
-
-        m_gstPlayerFactoryMock = std::make_shared<StrictMock<GstPlayerFactoryMock>>();
-        m_sharedMemoryBufferMock = std::make_shared<StrictMock<SharedMemoryBufferMock>>();
-
-        createMediaPipeline();
-    }
-
-    virtual void TearDown()
-    {
-        EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
-        m_mediaPipeline.reset();
-
-        m_gstPlayerFactoryMock.reset();
-        m_gstPlayerMock = nullptr;
-
-        m_mediaPipelineClient.reset();
-    }
-
-    void createMediaPipeline()
-    {
-        VideoRequirements videoReq = {};
-
-        EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
-        EXPECT_NO_THROW(
-            m_mediaPipeline =
-                std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClient, videoReq, m_gstPlayerFactoryMock,
-                                                              m_kSessionId, m_sharedMemoryBufferMock,
-                                                              std::move(m_dataReaderFactoryMock),
-                                                              std::move(m_activeRequestsMock), m_decryptionServiceMock););
-        EXPECT_NE(m_mediaPipeline, nullptr);
-    }
-
-    void LoadGstPlayer()
-    {
-        std::unique_ptr<StrictMock<GstPlayerMock>> gstPlayerMock = std::make_unique<StrictMock<GstPlayerMock>>();
-
-        // Save a raw pointer to the unique object for use when testing mocks
-        // Object shall be freed by the holder of the unique ptr on destruction
-        m_gstPlayerMock = gstPlayerMock.get();
-
-        EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, _)).WillOnce(Return(ByMove(std::move(gstPlayerMock))));
-        EXPECT_CALL(*m_mediaPipelineClient, notifyNetworkState(NetworkState::BUFFERING));
+    RialtoServerMediaPipelineSourceTest() { createMediaPipeline(); }
 
-        EXPECT_EQ(m_mediaPipeline->load(MediaType::MSE, "mime", "mse://1"), true);
-    }
+    ~RialtoServerMediaPipelineSourceTest() { destroyMediaPipeline(); }
 };
 
 /**
@@ -109,7 +38,8 @@ TEST_F(RialtoServerMediaPipelineSourceTest, AttachSourceSuccess)
 {
     IMediaPipeline::MediaSource m_mediaSource(m_id, m_type, m_kCaps);
 
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, attachSource(m_type, m_kCaps));
 
@@ -124,6 +54,7 @@ TEST_F(RialtoServerMediaPipelineSourceTest, NoGstPlayerFailure)
 {
     IMediaPipeline::MediaSource m_mediaSource(m_id, m_type, m_kCaps);
 
+    mainThreadWillEnqueueTaskAndWait();
     EXPECT_EQ(m_mediaPipeline->attachSource(m_mediaSource), false);
     EXPECT_EQ(m_mediaSource.getId(), -1);
 }
@@ -135,7 +66,8 @@ TEST_F(RialtoServerMediaPipelineSourceTest, TypeUnknownFailure)
 {
     IMediaPipeline::MediaSource m_mediaSource(m_id, MediaSourceType::UNKNOWN, m_kCaps);
 
-    LoadGstPlayer();
+    loadGstPlayer();
+    mainThreadWillEnqueueTaskAndWait();
 
     EXPECT_CALL(*m_gstPlayerMock, attachSource(_, _)).Times(0);
 
diff --git a/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.cpp b/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.cpp
new file mode 100644
index 0000000..b65dc30
--- /dev/null
+++ b/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.cpp
@@ -0,0 +1,89 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "MediaPipelineTestBase.h"
+#include <memory>
+#include <string>
+#include <utility>
+
+MediaPipelineTestBase::MediaPipelineTestBase()
+    : m_mediaPipelineClientMock{std::make_shared<StrictMock<MediaPipelineClientMock>>()},
+      m_gstPlayerFactoryMock{std::make_shared<StrictMock<GstPlayerFactoryMock>>()},
+      m_gstPlayer{std::make_unique<StrictMock<GstPlayerMock>>()},
+      m_gstPlayerMock{static_cast<StrictMock<GstPlayerMock> *>(m_gstPlayer.get())},
+      m_sharedMemoryBufferMock{std::make_shared<StrictMock<SharedMemoryBufferMock>>()},
+      m_dataReaderFactory{std::make_unique<StrictMock<DataReaderFactoryMock>>()},
+      m_dataReaderFactoryMock{static_cast<StrictMock<DataReaderFactoryMock> *>(m_dataReaderFactory.get())},
+      m_activeRequests{std::make_unique<StrictMock<ActiveRequestsMock>>()},
+      m_activeRequestsMock{static_cast<StrictMock<ActiveRequestsMock> *>(m_activeRequests.get())},
+      m_mainThreadFactoryMock{std::make_shared<StrictMock<MainThreadFactoryMock>>()},
+      m_mainThreadMock{std::make_shared<StrictMock<MainThreadMock>>()}
+{
+}
+
+MediaPipelineTestBase::~MediaPipelineTestBase() {}
+
+void MediaPipelineTestBase::createMediaPipeline()
+{
+    mainThreadWillEnqueueTaskAndWait();
+    EXPECT_CALL(*m_mainThreadFactoryMock, getMainThread()).WillOnce(Return(m_mainThreadMock));
+    EXPECT_CALL(*m_mainThreadMock, registerClient()).WillOnce(Return(m_kMainThreadClientId));
+    EXPECT_CALL(*m_sharedMemoryBufferMock, mapPartition(m_kSessionId)).WillOnce(Return(true));
+    EXPECT_NO_THROW(
+        m_mediaPipeline =
+            std::make_unique<MediaPipelineServerInternal>(m_mediaPipelineClientMock, m_videoReq, m_gstPlayerFactoryMock,
+                                                          m_kSessionId, m_sharedMemoryBufferMock,
+                                                          m_mainThreadFactoryMock, std::move(m_dataReaderFactory),
+                                                          std::move(m_activeRequests), m_decryptionServiceMock););
+    EXPECT_NE(m_mediaPipeline, nullptr);
+}
+
+void MediaPipelineTestBase::destroyMediaPipeline()
+{
+    EXPECT_CALL(*m_sharedMemoryBufferMock, unmapPartition(m_kSessionId)).WillOnce(Return(true));
+    EXPECT_CALL(*m_mainThreadMock, unregisterClient(m_kMainThreadClientId));
+    // Objects are destroyed on the main thread
+    mainThreadWillEnqueueTaskAndWait();
+
+    m_mediaPipeline.reset();
+}
+
+void MediaPipelineTestBase::mainThreadWillEnqueueTask()
+{
+    EXPECT_CALL(*m_mainThreadMock, enqueueTask(m_kMainThreadClientId, _))
+        .WillOnce(Invoke([](uint32_t clientId, firebolt::rialto::server::IMainThread::Task task) { task(); }))
+        .RetiresOnSaturation();
+}
+
+void MediaPipelineTestBase::mainThreadWillEnqueueTaskAndWait()
+{
+    EXPECT_CALL(*m_mainThreadMock, enqueueTaskAndWait(m_kMainThreadClientId, _))
+        .WillOnce(Invoke([](uint32_t clientId, firebolt::rialto::server::IMainThread::Task task) { task(); }))
+        .RetiresOnSaturation();
+}
+
+void MediaPipelineTestBase::loadGstPlayer()
+{
+    mainThreadWillEnqueueTaskAndWait();
+    mainThreadWillEnqueueTask();
+    EXPECT_CALL(*m_gstPlayerFactoryMock, createGstPlayer(_, _, _)).WillOnce(Return(ByMove(std::move(m_gstPlayer))));
+    EXPECT_CALL(*m_mediaPipelineClientMock, notifyNetworkState(NetworkState::BUFFERING));
+
+    EXPECT_EQ(m_mediaPipeline->load(MediaType::MSE, "mime", "mse://1"), true);
+}
diff --git a/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.h b/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.h
new file mode 100644
index 0000000..1819730
--- /dev/null
+++ b/tests/media/server/main/mediaPipeline/base/MediaPipelineTestBase.h
@@ -0,0 +1,88 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2022 Sky UK
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MEDIA_PIPELINE_TEST_BASE_H_
+#define MEDIA_PIPELINE_TEST_BASE_H_
+
+#include "ActiveRequestsMock.h"
+#include "DataReaderFactoryMock.h"
+#include "DataReaderMock.h"
+#include "DecryptionServiceMock.h"
+#include "GstPlayerFactoryMock.h"
+#include "GstPlayerMock.h"
+#include "IGstPlayerClient.h"
+#include "MainThreadFactoryMock.h"
+#include "MainThreadMock.h"
+#include "MediaPipelineClientMock.h"
+#include "MediaPipelineServerInternal.h"
+#include "SharedMemoryBufferMock.h"
+#include <gtest/gtest.h>
+#include <memory>
+
+using namespace firebolt::rialto;
+using namespace firebolt::rialto::server;
+using namespace firebolt::rialto::server::mock;
+
+using ::testing::_;
+using ::testing::Invoke;
+using ::testing::Return;
+using ::testing::StrictMock;
+
+namespace
+{
+constexpr int sessionId{1};
+} // namespace
+
+class MediaPipelineTestBase : public ::testing::Test
+{
+public:
+    MediaPipelineTestBase();
+    virtual ~MediaPipelineTestBase();
+
+protected:
+    // MediaPipelineServerInternal object
+    std::unique_ptr<MediaPipelineServerInternal> m_mediaPipeline;
+
+    // Strict Mocks
+    std::shared_ptr<StrictMock<MediaPipelineClientMock>> m_mediaPipelineClientMock;
+    std::shared_ptr<StrictMock<GstPlayerFactoryMock>> m_gstPlayerFactoryMock;
+    std::unique_ptr<StrictMock<GstPlayerMock>> m_gstPlayer;
+    StrictMock<GstPlayerMock> *m_gstPlayerMock;
+    std::shared_ptr<StrictMock<SharedMemoryBufferMock>> m_sharedMemoryBufferMock;
+    std::unique_ptr<StrictMock<DataReaderFactoryMock>> m_dataReaderFactory;
+    StrictMock<DataReaderFactoryMock> *m_dataReaderFactoryMock;
+    std::unique_ptr<StrictMock<ActiveRequestsMock>> m_activeRequests;
+    StrictMock<ActiveRequestsMock> *m_activeRequestsMock;
+    std::shared_ptr<StrictMock<MainThreadFactoryMock>> m_mainThreadFactoryMock;
+    std::shared_ptr<StrictMock<MainThreadMock>> m_mainThreadMock;
+    StrictMock<DecryptionServiceMock> m_decryptionServiceMock;
+
+    // Common variables
+    const int m_kSessionId{1};
+    const int32_t m_kMainThreadClientId = {5};
+    VideoRequirements m_videoReq = {};
+
+    void createMediaPipeline();
+    void destroyMediaPipeline();
+    void mainThreadWillEnqueueTask();
+    void mainThreadWillEnqueueTaskAndWait();
+    void loadGstPlayer();
+};
+
+#endif // MEDIA_PIPELINE_TEST_BASE_H_
diff --git a/tests/media/server/mocks/service/MainThreadMock.h b/tests/media/server/mocks/main/MainThreadFactoryMock.h
similarity index 65%
rename from tests/media/server/mocks/service/MainThreadMock.h
rename to tests/media/server/mocks/main/MainThreadFactoryMock.h
index 264a536..971f82c 100644
--- a/tests/media/server/mocks/service/MainThreadMock.h
+++ b/tests/media/server/mocks/main/MainThreadFactoryMock.h
@@ -17,21 +17,21 @@
  * limitations under the License.
  */
 
-#ifndef FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_MOCK_H_
-#define FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_MOCK_H_
+#ifndef FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_FACTORY_MOCK_H_
+#define FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_FACTORY_MOCK_H_
 
 #include "IMainThread.h"
 #include <gmock/gmock.h>
 #include <memory>
 #include <string>
 
-namespace firebolt::rialto::server::service
+namespace firebolt::rialto::server::mock
 {
-class MainThreadMock : public IMainThread
+class MainThreadFactoryMock : public IMainThreadFactory
 {
 public:
-    MOCK_METHOD(void, enqueueTask, (Task task), (override));
+    MOCK_METHOD(std::shared_ptr<IMainThread>, getMainThread, (), (const, override));
 };
-} // namespace firebolt::rialto::server::service
+} // namespace firebolt::rialto::server::mock
 
-#endif // FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_MOCK_H_
+#endif // FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_FACTORY_MOCK_H_
diff --git a/media/server/service/source/MainThread.h b/tests/media/server/mocks/main/MainThreadMock.h
similarity index 51%
rename from media/server/service/source/MainThread.h
rename to tests/media/server/mocks/main/MainThreadMock.h
index b9d3f6b..2702a6c 100644
--- a/media/server/service/source/MainThread.h
+++ b/tests/media/server/mocks/main/MainThreadMock.h
@@ -17,41 +17,24 @@
  * limitations under the License.
  */
 
-#ifndef FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_H_
-#define FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_H_
+#ifndef FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_MOCK_H_
+#define FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_MOCK_H_
 
 #include "IMainThread.h"
-#include <condition_variable>
-#include <map>
+#include <gmock/gmock.h>
 #include <memory>
-#include <mutex>
-#include <queue>
 #include <string>
-#include <thread>
 
-namespace firebolt::rialto::server::service
+namespace firebolt::rialto::server::mock
 {
-/**
- * @brief The definition of the MediaKeys.
- */
-class MainThread : public IMainThread
+class MainThreadMock : public IMainThread
 {
 public:
-    MainThread();
-    virtual ~MainThread();
-
-    void enqueueTask(Task task) override;
-
-private:
-    void mainThreadLoop();
-    Task waitForTask();
-
-    bool m_isMainThreadRunning;
-    std::thread m_thread;
-    std::mutex m_taskMutex;
-    std::condition_variable m_taskCv;
-    std::queue<Task> m_taskQueue;
+    MOCK_METHOD(int32_t, registerClient, (), (override));
+    MOCK_METHOD(void, unregisterClient, (uint32_t clientId), (override));
+    MOCK_METHOD(void, enqueueTask, (uint32_t clientId, Task task), (override));
+    MOCK_METHOD(void, enqueueTaskAndWait, (uint32_t clientId, Task task), (override));
 };
-} // namespace firebolt::rialto::server::service
+} // namespace firebolt::rialto::server::mock
 
-#endif // FIREBOLT_RIALTO_SERVER_SERVICE_MAIN_THREAD_H_
+#endif // FIREBOLT_RIALTO_SERVER_MOCK_MAIN_THREAD_MOCK_H_
diff --git a/tests/media/server/service/cdmService/CdmServiceTests.cpp b/tests/media/server/service/cdmService/CdmServiceTests.cpp
index 0a1b5a0..c05e2a2 100644
--- a/tests/media/server/service/cdmService/CdmServiceTests.cpp
+++ b/tests/media/server/service/cdmService/CdmServiceTests.cpp
@@ -21,29 +21,18 @@
 
 TEST_F(CdmServiceTests, shouldFailToCreateMediaKeysInInactiveState)
 {
-    mainThreadWillEnqueueTask();
     createMediaKeysShouldFail();
 }
 
-TEST_F(CdmServiceTests, shouldFailSwitchToActiveIfCapabilitiesAreNull)
-{
-    mediaKeysCapabilitiesFactoryWillReturnNullptr();
-    triggerSwitchToActiveFail();
-}
-
 TEST_F(CdmServiceTests, shouldFailToCreateMediaKeysAfterSwitchToInactive)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     triggerSwitchToInactive();
-    mainThreadWillEnqueueTask();
     createMediaKeysShouldFail();
 }
 
 TEST_F(CdmServiceTests, shouldFailToCreateMediaKeysWhenFactoryReturnsNull)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillReturnNullptr();
     createMediaKeysShouldFail();
@@ -51,7 +40,6 @@ TEST_F(CdmServiceTests, shouldFailToCreateMediaKeysWhenFactoryReturnsNull)
 
 TEST_F(CdmServiceTests, shouldCreateMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
@@ -59,79 +47,63 @@ TEST_F(CdmServiceTests, shouldCreateMediaKeys)
 
 TEST_F(CdmServiceTests, shouldFailToCreateMediaKeysWithTheSameHandleTwice)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
-    mainThreadWillEnqueueTask();
     createMediaKeysShouldFail();
 }
 
 TEST_F(CdmServiceTests, shouldFailToDestroyNotExistingMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldFail();
 }
 
 TEST_F(CdmServiceTests, shouldDestroyMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldDestroyMediaKeysWhenSwitchedToInactive)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
-    mainThreadWillEnqueueTask();
     triggerSwitchToInactive();
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldFail();
 }
 
 TEST_F(CdmServiceTests, shouldCreateKeySession)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillCreateKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     createKeySessionShouldSucceed();
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToCreateKeySessionWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     createKeySessionShouldFailWithReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToCreateKeySessionWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillCreateKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     createKeySessionShouldFailWithReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToCreateKeySessionWhenMediaKeysClientExists)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
@@ -144,161 +116,131 @@ TEST_F(CdmServiceTests, shouldFailToCreateKeySessionWhenMediaKeysClientExists)
 
 TEST_F(CdmServiceTests, shouldGenerateRequest)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillGenerateRequestWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     generateRequestShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToGenerateRequestWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     generateRequestShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToGenerateRequestWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillGenerateRequestWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     generateRequestShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldLoadSession)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillLoadSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     loadSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToLoadSessionWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     loadSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToLoadSessionWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillLoadSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     loadSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldUpdateSession)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillUpdateSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     updateSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToUpdateSessionWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     updateSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToUpdateSessionWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillUpdateSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     updateSessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldCloseKeySession)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillCloseKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     closeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToCloseKeySessionWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     closeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToCloseKeySessionWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillCloseKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     closeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldRemoveKeySession)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillRemoveKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     removeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToRemoveKeySessionWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     removeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToRemoveKeySessionWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillRemoveKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     removeKeySessionShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
@@ -336,33 +278,27 @@ TEST_F(CdmServiceTests, shouldFailToGetCdmKeySessionIdWhenMediaKeysFails)
 
 TEST_F(CdmServiceTests, shouldDecrypt)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillDecryptWithStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
     decryptShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::OK);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldFailToDecryptWhenNoMediaKeys)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
-    mainThreadWillEnqueueTask();
     decryptShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::FAIL);
 }
 
 TEST_F(CdmServiceTests, shouldFailToDecryptWhenMediaKeysFails)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
     mediaKeysFactoryWillCreateMediaKeys();
     createMediaKeysShouldSucceed();
     mediaKeysWillDecryptWithStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
     decryptShouldReturnStatus(firebolt::rialto::MediaKeyErrorStatus::INVALID_STATE);
-    mainThreadWillEnqueueTask();
     destroyMediaKeysShouldSucceed();
 }
 
@@ -380,50 +316,68 @@ TEST_F(CdmServiceTests, shouldFailToDecryptWhenMediaKeysIsNotFoundForSession)
 
 TEST_F(CdmServiceTests, shouldGetNoKeySystemsFromGetSupportedKeySystemsInInactiveState)
 {
-    mainThreadWillEnqueueTask();
+    getSupportedKeySystemsReturnNon();
+}
+
+TEST_F(CdmServiceTests, shouldGetNoKeySystemsFromGetSupportedKeySystemsIfCreationFailureInActiveState)
+{
+    triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillReturnNullptr();
     getSupportedKeySystemsReturnNon();
 }
 
 TEST_F(CdmServiceTests, shouldGetSupportedKeySystemsInActiveState)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     getSupportedKeySystemsWillReturnKeySystems();
     getSupportedKeySystemsShouldSucceed();
 }
 
 TEST_F(CdmServiceTests, shouldGetKeySystemNotSupportedInInactiveState)
 {
-    mainThreadWillEnqueueTask();
+    supportsKeySystemReturnFalse();
+}
+
+TEST_F(CdmServiceTests, shouldGetKeySystemNotSupportedIfCreationFailureInActiveState)
+{
+    triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillReturnNullptr();
     supportsKeySystemReturnFalse();
 }
 
 TEST_F(CdmServiceTests, shouldGetKeySystemSupportedIfSupportedInActiveState)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     supportsKeySystemWillReturnTrue();
     supportsKeySystemReturnTrue();
 }
 
 TEST_F(CdmServiceTests, shouldFailToGetSupportedKeySystemVersionInInactiveState)
 {
-    mainThreadWillEnqueueTask();
     getSupportedKeySystemVersionShouldFail();
 }
 
-TEST_F(CdmServiceTests, shouldFailToGetSupportedKeySystemVersionIfFailureInActiveState)
+TEST_F(CdmServiceTests, shouldFailToGetSupportedKeySystemVersionIfCreationFailureInActiveState)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillReturnNullptr();
+    getSupportedKeySystemVersionShouldFail();
+}
+
+TEST_F(CdmServiceTests, shouldFailToGetSupportedKeySystemVersionIfApiFailureInActiveState)
+{
+    triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     getSupportedKeySystemVersionWillFail();
     getSupportedKeySystemVersionShouldFail();
 }
 
 TEST_F(CdmServiceTests, shouldGetSupportedKeySystemVersionInActiveState)
 {
-    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     triggerSwitchToActiveSuccess();
+    mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities();
     getSupportedKeySystemVersionWillSucceed();
     getSupportedKeySystemVersionShouldSucceed();
 }
diff --git a/tests/media/server/service/cdmService/CdmServiceTestsFixture.cpp b/tests/media/server/service/cdmService/CdmServiceTestsFixture.cpp
index 288467c..5579037 100644
--- a/tests/media/server/service/cdmService/CdmServiceTestsFixture.cpp
+++ b/tests/media/server/service/cdmService/CdmServiceTestsFixture.cpp
@@ -57,51 +57,38 @@ CdmServiceTests::CdmServiceTests()
       m_mediaKeysCapabilitiesMock{
           dynamic_cast<StrictMock<firebolt::rialto::mock::MediaKeysCapabilitiesMock> &>(*m_mediaKeysCapabilities)},
       m_mediaKeysClientMock{std::make_shared<StrictMock<firebolt::rialto::mock::MediaKeysClientMock>>()},
-      m_sut{m_mainThreadMock, m_mediaKeysFactoryMock, m_mediaKeysCapabilitiesFactoryMock}
+      m_sut{m_mediaKeysFactoryMock, m_mediaKeysCapabilitiesFactoryMock}
 {
 }
 
-void CdmServiceTests::mainThreadWillEnqueueTask()
-{
-    EXPECT_CALL(m_mainThreadMock, enqueueTask(_))
-        .WillOnce(Invoke([](firebolt::rialto::server::service::IMainThread::Task task) { task(); }))
-        .RetiresOnSaturation();
-}
-
 void CdmServiceTests::mediaKeysCapabilitiesFactoryWillCreateMediaKeysCapabilities()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaKeysCapabilitiesFactoryMock, getMediaKeysCapabilities()).WillOnce(Return(m_mediaKeysCapabilities));
 }
 
 void CdmServiceTests::mediaKeysCapabilitiesFactoryWillReturnNullptr()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaKeysCapabilitiesFactoryMock, getMediaKeysCapabilities()).WillOnce(Return(nullptr));
 }
 
 void CdmServiceTests::getSupportedKeySystemsWillReturnKeySystems()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysCapabilitiesMock, getSupportedKeySystems()).WillOnce(Return(keySystems));
 }
 
 void CdmServiceTests::supportsKeySystemWillReturnTrue()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysCapabilitiesMock, supportsKeySystem(keySystems[0])).WillOnce(Return(true));
 }
 
 void CdmServiceTests::getSupportedKeySystemVersionWillSucceed()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysCapabilitiesMock, getSupportedKeySystemVersion(keySystems[0], _))
         .WillOnce(DoAll(SetArgReferee<1>(version), Return(true)));
 }
 
 void CdmServiceTests::getSupportedKeySystemVersionWillFail()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysCapabilitiesMock, getSupportedKeySystemVersion(keySystems[0], _))
         .WillOnce(DoAll(SetArgReferee<1>(version), Return(false)));
 }
@@ -111,11 +98,6 @@ void CdmServiceTests::triggerSwitchToActiveSuccess()
     EXPECT_TRUE(m_sut.switchToActive());
 }
 
-void CdmServiceTests::triggerSwitchToActiveFail()
-{
-    EXPECT_FALSE(m_sut.switchToActive());
-}
-
 void CdmServiceTests::triggerSwitchToInactive()
 {
     m_sut.switchToInactive();
@@ -123,51 +105,43 @@ void CdmServiceTests::triggerSwitchToInactive()
 
 void CdmServiceTests::mediaKeysFactoryWillCreateMediaKeys()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaKeysFactoryMock, createMediaKeysServerInternal(_)).WillOnce(Return(ByMove(std::move(m_mediaKeys))));
 }
 
 void CdmServiceTests::mediaKeysFactoryWillReturnNullptr()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaKeysFactoryMock, createMediaKeysServerInternal(_))
         .WillOnce(Return(ByMove(std::unique_ptr<firebolt::rialto::server::IMediaKeysServerInternal>())));
 }
 
 void CdmServiceTests::mediaKeysWillCreateKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, createKeySession(keySessionType, _, isLDL, _))
         .WillOnce(DoAll(SetArgReferee<3>(keySessionId), Return(status)));
 }
 
 void CdmServiceTests::mediaKeysWillGenerateRequestWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, generateRequest(keySessionId, initDataType, initData)).WillOnce(Return(status));
 }
 
 void CdmServiceTests::mediaKeysWillLoadSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, loadSession(keySessionId)).WillOnce(Return(status));
 }
 
 void CdmServiceTests::mediaKeysWillUpdateSessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, updateSession(keySessionId, responseData)).WillOnce(Return(status));
 }
 
 void CdmServiceTests::mediaKeysWillCloseKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, closeKeySession(keySessionId)).WillOnce(Return(status));
 }
 
 void CdmServiceTests::mediaKeysWillRemoveKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, removeKeySession(keySessionId)).WillOnce(Return(status));
 }
 
@@ -179,7 +153,6 @@ void CdmServiceTests::mediaKeysWillGetCdmKeySessionIdWithStatus(firebolt::rialto
 
 void CdmServiceTests::mediaKeysWillDecryptWithStatus(firebolt::rialto::MediaKeyErrorStatus status)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaKeysMock, hasSession(keySessionId)).WillOnce(Return(true));
     EXPECT_CALL(m_mediaKeysMock, decrypt(keySessionId, _, _, subSampleCount, _, _, initWithLast15)).WillOnce(Return(status));
 }
diff --git a/tests/media/server/service/cdmService/CdmServiceTestsFixture.h b/tests/media/server/service/cdmService/CdmServiceTestsFixture.h
index 76727c7..99da44e 100644
--- a/tests/media/server/service/cdmService/CdmServiceTestsFixture.h
+++ b/tests/media/server/service/cdmService/CdmServiceTestsFixture.h
@@ -21,7 +21,6 @@
 #define CDM_SERVICE_TESTS_FIXTURE_H_
 
 #include "CdmService.h"
-#include "MainThreadMock.h"
 #include "MediaKeysCapabilitiesFactoryMock.h"
 #include "MediaKeysCapabilitiesMock.h"
 #include "MediaKeysClientMock.h"
@@ -41,8 +40,6 @@ public:
     CdmServiceTests();
     ~CdmServiceTests() = default;
 
-    void mainThreadWillEnqueueTask();
-
     void mediaKeysFactoryWillCreateMediaKeys();
     void mediaKeysFactoryWillReturnNullptr();
     void mediaKeysWillCreateKeySessionWithStatus(firebolt::rialto::MediaKeyErrorStatus status);
@@ -63,7 +60,6 @@ public:
     void getSupportedKeySystemVersionWillFail();
 
     void triggerSwitchToActiveSuccess();
-    void triggerSwitchToActiveFail();
     void triggerSwitchToInactive();
 
     void createMediaKeysShouldSucceed();
@@ -88,7 +84,6 @@ public:
     void getSupportedKeySystemVersionShouldFail();
 
 private:
-    StrictMock<firebolt::rialto::server::service::MainThreadMock> m_mainThreadMock;
     std::shared_ptr<StrictMock<firebolt::rialto::server::MediaKeysServerInternalFactoryMock>> m_mediaKeysFactoryMock;
     std::unique_ptr<firebolt::rialto::server::IMediaKeysServerInternal> m_mediaKeys;
     StrictMock<firebolt::rialto::server::MediaKeysServerInternalMock> &m_mediaKeysMock;
diff --git a/tests/media/server/service/playbackService/PlaybackServiceTests.cpp b/tests/media/server/service/playbackService/PlaybackServiceTests.cpp
index 3964985..1028cae 100644
--- a/tests/media/server/service/playbackService/PlaybackServiceTests.cpp
+++ b/tests/media/server/service/playbackService/PlaybackServiceTests.cpp
@@ -21,7 +21,6 @@
 
 TEST_F(PlaybackServiceTests, shouldFailToCreateSessionInInactiveState)
 {
-    mainThreadWillEnqueueTask();
     createSessionShouldFail();
 }
 
@@ -30,9 +29,7 @@ TEST_F(PlaybackServiceTests, shouldFailToCreateSessionAfterSwitchToInactive)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     triggerSwitchToInactive();
-    mainThreadWillEnqueueTask();
     createSessionShouldFail();
 }
 
@@ -41,7 +38,6 @@ TEST_F(PlaybackServiceTests, shouldFailToCreateSessionAfterFailedSwitchToActive)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillFailToInitialize();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     createSessionShouldFail();
 }
 
@@ -51,7 +47,6 @@ TEST_F(PlaybackServiceTests, shouldFailToCreateSessionWhenMaxPlaybackSessionsIsR
     triggerSetMaxPlaybacks(maxPlaybacks);
     sharedMemoryBufferWillBeInitialized(maxPlaybacks);
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     createSessionShouldFail();
 }
 
@@ -81,7 +76,6 @@ TEST_F(PlaybackServiceTests, shouldFailToCreateSessionWithTheSameIdTwice)
     triggerSwitchToActive();
     mediaPipelineFactoryWillCreateMediaPipeline();
     createSessionShouldSucceed();
-    mainThreadWillEnqueueTask();
     createSessionShouldFail();
 }
 
@@ -90,7 +84,6 @@ TEST_F(PlaybackServiceTests, shouldFailToDestroyNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     destroySessionShouldFail();
 }
 
@@ -101,7 +94,6 @@ TEST_F(PlaybackServiceTests, shouldDestroySession)
     triggerSwitchToActive();
     mediaPipelineFactoryWillCreateMediaPipeline();
     createSessionShouldSucceed();
-    mainThreadWillEnqueueTask();
     destroySessionShouldSucceed();
 }
 
@@ -112,9 +104,7 @@ TEST_F(PlaybackServiceTests, shouldDestroySessionWhenSwitchedToInactive)
     triggerSwitchToActive();
     mediaPipelineFactoryWillCreateMediaPipeline();
     createSessionShouldSucceed();
-    mainThreadWillEnqueueTask();
     triggerSwitchToInactive();
-    mainThreadWillEnqueueTask();
     destroySessionShouldFail();
 }
 
@@ -123,7 +113,6 @@ TEST_F(PlaybackServiceTests, shouldFailToLoadNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     loadShouldFail();
 }
 
@@ -154,7 +143,6 @@ TEST_F(PlaybackServiceTests, shouldFailToAttachSourceForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     attachSourceShouldFail();
 }
 
@@ -185,7 +173,6 @@ TEST_F(PlaybackServiceTests, shouldFailToRemoveSourceForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     removeSourceShouldFail();
 }
 
@@ -216,7 +203,6 @@ TEST_F(PlaybackServiceTests, shouldFailToPlayForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     playShouldFail();
 }
 
@@ -247,7 +233,6 @@ TEST_F(PlaybackServiceTests, shouldFailToStopForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     stopShouldFail();
 }
 
@@ -278,7 +263,6 @@ TEST_F(PlaybackServiceTests, shouldFailToPauseForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     pauseShouldFail();
 }
 
@@ -309,7 +293,6 @@ TEST_F(PlaybackServiceTests, shouldFailToSetPlaybackRateForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     setPlaybackRateShouldFail();
 }
 
@@ -340,7 +323,6 @@ TEST_F(PlaybackServiceTests, shouldFailToSetPositionForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     setPositionShouldFail();
 }
 
@@ -371,7 +353,6 @@ TEST_F(PlaybackServiceTests, shouldFailToSetVideoWindowForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     setVideoWindowShouldFail();
 }
 
@@ -402,7 +383,6 @@ TEST_F(PlaybackServiceTests, shouldFailToHaveDataForNotExistingSession)
     triggerSetMaxPlaybacks();
     sharedMemoryBufferWillBeInitialized();
     triggerSwitchToActive();
-    mainThreadWillEnqueueTask();
     haveDataShouldFail();
 }
 
@@ -430,7 +410,6 @@ TEST_F(PlaybackServiceTests, shouldHaveData)
 
 TEST_F(PlaybackServiceTests, shouldFailToGetSharedMemoryInInactiveState)
 {
-    mainThreadWillEnqueueTask();
     getSharedMemoryShouldFail();
 }
 
diff --git a/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.cpp b/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.cpp
index 5faae7b..f6e4afa 100644
--- a/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.cpp
+++ b/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.cpp
@@ -68,154 +68,125 @@ PlaybackServiceTests::PlaybackServiceTests()
       m_mediaPipeline{std::make_unique<StrictMock<firebolt::rialto::server::MediaPipelineServerInternalMock>>()},
       m_mediaPipelineMock{
           dynamic_cast<StrictMock<firebolt::rialto::server::MediaPipelineServerInternalMock> &>(*m_mediaPipeline)},
-      m_sut{m_mainThreadMock, m_mediaPipelineFactoryMock, std::move(m_shmBufferFactory), m_decryptionServiceMock}
+      m_sut{m_mediaPipelineFactoryMock, std::move(m_shmBufferFactory), m_decryptionServiceMock}
 {
 }
 
-void PlaybackServiceTests::mainThreadWillEnqueueTask()
-{
-    EXPECT_CALL(m_mainThreadMock, enqueueTask(_))
-        .WillOnce(Invoke([](firebolt::rialto::server::service::IMainThread::Task task) { task(); }));
-}
-
 void PlaybackServiceTests::sharedMemoryBufferWillBeInitialized(int maxPlaybacks)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_shmBufferFactoryMock, createSharedMemoryBuffer(maxPlaybacks))
         .WillOnce(Return(ByMove(std::move(m_shmBuffer))));
 }
 
 void PlaybackServiceTests::sharedMemoryBufferWillFailToInitialize(int maxPlaybacks)
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_shmBufferFactoryMock, createSharedMemoryBuffer(maxPlaybacks))
         .WillOnce(Throw(std::runtime_error("Buffer creation failed")));
 }
 
 void PlaybackServiceTests::sharedMemoryBufferWillReturnFdAndSize()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_shmBufferMock, getFd()).WillOnce(Return(shmFd));
     EXPECT_CALL(m_shmBufferMock, getSize()).WillOnce(Return(shmSize));
 }
 
 void PlaybackServiceTests::mediaPipelineWillLoad()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, load(type, mimeType, url)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToLoad()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, load(type, mimeType, url)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillAttachSource()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, attachSource(_)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToAttachSource()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, attachSource(_)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillRemoveSource()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, removeSource(sourceId)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToRemoveSource()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, removeSource(sourceId)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillPlay()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, play()).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToPlay()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, play()).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillPause()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, pause()).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToPause()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, pause()).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillStop()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, stop()).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToStop()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, stop()).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillSetPlaybackRate()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setPlaybackRate(rate)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToSetPlaybackRate()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setPlaybackRate(rate)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillSetPosition()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setPosition(position)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToSetPosition()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setPosition(position)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillSetVideoWindow()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setVideoWindow(x, y, width, height)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToSetVideoWindow()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, setVideoWindow(x, y, width, height)).WillOnce(Return(false));
 }
 
 void PlaybackServiceTests::mediaPipelineWillHaveData()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, haveData(status, numFrames, needDataRequestId)).WillOnce(Return(true));
 }
 
 void PlaybackServiceTests::mediaPipelineWillFailToHaveData()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(m_mediaPipelineMock, haveData(status, numFrames, needDataRequestId)).WillOnce(Return(false));
 }
 
@@ -234,14 +205,12 @@ void PlaybackServiceTests::mediaPipelineWillFailToGetPosition()
 
 void PlaybackServiceTests::mediaPipelineFactoryWillCreateMediaPipeline()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaPipelineFactoryMock, createMediaPipelineServerInternal(_, requirements, _, _, _))
         .WillOnce(Return(ByMove(std::move(m_mediaPipeline))));
 }
 
 void PlaybackServiceTests::mediaPipelineFactoryWillReturnNullptr()
 {
-    mainThreadWillEnqueueTask();
     EXPECT_CALL(*m_mediaPipelineFactoryMock, createMediaPipelineServerInternal(_, requirements, _, _, _))
         .WillOnce(Return(ByMove(std::unique_ptr<firebolt::rialto::server::IMediaPipelineServerInternal>())));
 }
diff --git a/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.h b/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.h
index 2fdb4f8..0efc242 100644
--- a/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.h
+++ b/tests/media/server/service/playbackService/PlaybackServiceTestsFixture.h
@@ -21,7 +21,6 @@
 #define PLAYBACK_SERVICE_TESTS_FIXTURE_H_
 
 #include "DecryptionServiceMock.h"
-#include "MainThreadMock.h"
 #include "MediaPipelineServerInternalFactoryMock.h"
 #include "MediaPipelineServerInternalMock.h"
 #include "PlaybackService.h"
@@ -42,8 +41,6 @@ public:
     void sharedMemoryBufferWillFailToInitialize(int maxPlaybacks = 1);
     void sharedMemoryBufferWillReturnFdAndSize();
 
-    void mainThreadWillEnqueueTask();
-
     void mediaPipelineWillLoad();
     void mediaPipelineWillFailToLoad();
     void mediaPipelineWillAttachSource();
@@ -104,7 +101,6 @@ public:
     void getPositionShouldFail();
 
 private:
-    StrictMock<firebolt::rialto::server::service::MainThreadMock> m_mainThreadMock;
     std::shared_ptr<StrictMock<firebolt::rialto::server::MediaPipelineServerInternalFactoryMock>> m_mediaPipelineFactoryMock;
     std::unique_ptr<firebolt::rialto::server::ISharedMemoryBufferFactory> m_shmBufferFactory;
     StrictMock<firebolt::rialto::server::SharedMemoryBufferFactoryMock> &m_shmBufferFactoryMock;
